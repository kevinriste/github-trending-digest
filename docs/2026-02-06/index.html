<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 06, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 06, 2026</h1>
        <nav>
            <a href="../">&larr; GitHub Calendar</a>
            <a href="../hn/">Hacker News</a>
        </nav>
    </header>
    <main>
        <div class="repo-controls">
            <button id="collapse-seen-btn" type="button">Collapse Seen Repos</button>
            <button id="expand-all-btn" type="button">Expand All</button>
        </div>
        <article>
            <div class="repos">

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>1. <a href="https://github.com/bytedance/UI-TARS-desktop" target="_blank" rel="noopener noreferrer">bytedance/UI-TARS-desktop</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">The Open-Source Multimodal AI Agent Stack: Connecting Cutting-Edge AI Models and Agent Infra</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">26,836 stars</span>
                        | <span class="today">566 stars today</span>
                    </p>
                    <p class="history">First seen: February 06, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>UI-TARS-desktop is an open-source multimodal AI agent stack that provides a CLI, web UI and a native desktop application for automating and controlling GUIs, browsers, and remote machines using vision-language models. Its main features include a hybrid browser agent (GUI/DOM/hybrid control), Event Stream protocol for context and debugging, MCP integration for connecting real-world tools, and built-in capabilities like screenshot-based visual recognition, precise mouse/keyboard control, and remote computer/browser operators. Technically it runs multimodal LLMs (e.g., UI-TARS and Seed VL series) through a kernel built on the MCP framework, supports headful and headless execution, streaming tool calls, sandboxed tool execution, and can be launched via an npm-based CLI that connects to various model providers. The project emphasizes cross-platform local operation, an SDK for GUI automation, and extensibility via model/provider configuration and mounting MCP servers.</p>
<p>This project is valuable for developers, QA engineers, RPA teams, and researchers who need programmatic GUI automation, multimodal agent workflows, or privacy-preserving local agents for desktop tasks. Typical use cases include automated end-to-end browser workflows, remote desktop/browser control, GUI testing and automation, accessibility tooling, and building higher-level assistants that integrate real-world tools and streaming tool outputs. Its combination of multimodal LLM control, tool mounting, event streaming, and one-click CLI deployment makes it attractive for rapid prototyping and production automation, while open-source licensing and local processing address reproducibility and data privacy concerns—factors driving its adoption and visibility.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>2. <a href="https://github.com/openai/skills" target="_blank" rel="noopener noreferrer">openai/skills</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Skills Catalog for Codex</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">4,420 stars</span>
                        | <span class="today">621 stars today</span>
                    </p>
                    <p class="history">First seen: February 04, 2026 | Consecutive daily streak: 3 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository catalogs &quot;Agent Skills&quot;—self-contained folders of instructions, scripts, and resources that Codex-based AI agents can discover and use to perform specific tasks. Its main features include a curated and experimental skills layout, automatic installation of .system skills, and a $skill-installer command that adds skills by name, folder, or GitHub directory URL; each skill carries its own LICENSE.txt and follows the Agent Skills open standard. Technically, skills are packaged as directory-based modules that Codex imports at runtime (requiring a restart to pick up new skills), enabling repeatable, shareable capabilities composed of prompts, scripts, and ancillary assets. The repository therefore acts as both a registry and distribution mechanism for modular agent behaviors.</p>
<p>The project is valuable to developers, product teams, and organizations building agent-driven automation because it centralizes reusable, testable components that speed development and reduce duplication of effort. Use cases include domain-specific automation, standardized prompt and workflow sharing, rapid prototyping of agent capabilities, and collaboration across teams that need consistent agent behavior. It’s gaining traction because modular, discoverable skills align with the broader trend toward agentization and platformization of AI tooling, making it easier to scale and govern autonomous workflows.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>3. <a href="https://github.com/thedotmack/claude-mem" target="_blank" rel="noopener noreferrer">thedotmack/claude-mem</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">A Claude Code plugin that automatically captures everything Claude does during your coding sessions, compresses it with AI (using Claude&#x27;s agent-sdk), and injects relevant context back into future sessions.</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">23,850 stars</span>
                        | <span class="today">1,930 stars today</span>
                    </p>
                    <p class="history">First seen: February 02, 2026 | Consecutive daily streak: 5 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Claude-Mem is a Claude Code plugin that automatically captures Claude’s tool usage and observations during coding sessions, compresses them with the Claude agent-sdk, stores them in a local database, and injects relevant context into future sessions. Technically it uses lifecycle hook scripts to intercept session events, a Bun-managed worker HTTP service (default port 37777) with a web viewer, SQLite (with FTS5) for persistence, and a Chroma vector DB for hybrid semantic search. Retrieval is token-efficient via MCP tools (search → timeline → get_observations) implementing progressive disclosure, and the system includes configuration, privacy exclusion tags, citationable observation IDs, and a beta channel for experimental features like Endless Mode.</p>
<p>This tool benefits individual developers and teams who need continuity across ephemeral AI sessions by reducing repetitive context copying, accelerating debugging and onboarding, and preserving project knowledge and decision history. Its token-aware progressive retrieval and hybrid search make it cost-efficient for large histories, while local storage and privacy controls suit sensitive codebases. Because it integrates directly into Claude Code and leverages the agent SDK for automated summarization and injection, it’s attractive to users looking for persistent, reproducible AI-assisted coding workflows.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>4. <a href="https://github.com/j178/prek" target="_blank" rel="noopener noreferrer">j178/prek</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">⚡ Better `pre-commit`, re-engineered in Rust</p>
                    <p class="meta">
                        <span class="language">Rust</span> |
                        <span class="stars">5,571 stars</span>
                        | <span class="today">258 stars today</span>
                    </p>
                    <p class="history">First seen: February 02, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>prek is a Rust reimplementation of the pre-commit framework that runs and manages multi-language hooks as a single standalone binary without requiring Python or other runtimes. Its main features include faster execution, reduced disk usage, full compatibility with pre-commit configurations, workspace/monorepo support, built-in Rust implementations of common hooks, and shared toolchain installation for Python, Node.js, Bun, Go, Rust, and Ruby. Technically, prek centrally manages toolchains and dependencies (leveraging uv for Python virtualenvs), clones repositories and installs dependencies in parallel, shares environments between hooks, and executes hooks concurrently by priority to minimize end-to-end runtime.</p>
<p>prek is valuable to developers, CI/CD pipelines, and maintainers who want a drop-in, faster alternative to pre-commit with minimal runtime friction. Large codebases and monorepos, or projects that run many heterogeneous hooks, benefit most from shared toolchains, parallel installs, and Rust-native hooks that reduce CI time and disk use. Its adoption by projects such as CPython, Apache Airflow, and FastAPI highlights practical gains in performance and ease of integration, while the single-binary distribution and multiple install options simplify onboarding and automated workflows.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>5. <a href="https://github.com/topoteretes/cognee" target="_blank" rel="noopener noreferrer">topoteretes/cognee</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Memory for AI Agents in 6 lines of code</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">11,887 stars</span>
                        | <span class="today">74 stars today</span>
                    </p>
                    <p class="history">First seen: February 06, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Cognee is an open-source framework that converts raw data into persistent, dynamic memory for AI agents by combining dense vector search with knowledge graphs. It implements an ECL (Extract, Cognify, Load) pipeline to ingest content from 30+ data sources, uses LLMs to &quot;cognify&quot; documents into a knowledge graph and embeddings, and then &quot;memifies&quot; the graph by attaching memory algorithms and metadata. Technically, Cognee stores both semantic vectors and explicit relationships so queries can leverage meaning-based retrieval and relationship-aware reasoning; it is accessible via an async Python API, a CLI, and customizable modular pipelines. The project supports multiple LLM providers, targets Python 3.10–3.13, and ships with default pipelines and demos to get started quickly.</p>
<p>Cognee is valuable for teams building conversational agents, persistent assistant memory, knowledge management systems, and researchers exploring hybrid graph/vector reasoning, because it replaces ad-hoc RAG setups with a unified memory layer that can lower infrastructure cost and improve precision. Developers benefit from the Pythonic ingestion pipelines, CLI, and extensibility to implement domain-specific tasks or scale production deployments. The project is gaining traction due to rising interest in agent-centric architectures and research showing that combining graphs with LLMs improves complex reasoning, plus its open-source ecosystem and reproducible demos that lower adoption barriers.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>6. <a href="https://github.com/obra/superpowers" target="_blank" rel="noopener noreferrer">obra/superpowers</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">An agentic skills framework &amp; software development methodology that works.</p>
                    <p class="meta">
                        <span class="language">Shell</span> |
                        <span class="stars">45,598 stars</span>
                        | <span class="today">887 stars today</span>
                    </p>
                    <p class="history">First seen: February 04, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Superpowers is a complete software development workflow for coding agents built around composable &quot;skills&quot; and starter instructions that make agents follow a consistent process. Key features include a modular skills library (TDD, systematic debugging, brainstorming, plan-writing, subagent-driven development, code review, and git worktree management), an enforced workflow that moves from spec elicitation to plan to task-level subagents, and a two-stage review system (spec compliance then code quality). Technically it ships as a plugin (Claude Code marketplace) with manual install paths for Codex and OpenCode, stores skills directly in the repository, and has agents fetch and execute skills, spawn subagents per task, and run automated verification and test-driven cycles. The repo also contains contribution guidance and update mechanics so skills can be extended and updated easily.</p>
<p>This project benefits developers, teams, and tool builders who want repeatable, evidence-driven AI-assisted engineering—especially those who need automated testing, clear task plans, and controlled parallel work via subagents. It’s gaining traction because it addresses practical pain points in agentic coding (avoiding ad-hoc behavior, enforcing RED‑GREEN‑REFACTOR, and integrating with git workflows) while offering an easy integration path for Claude Code and extensibility via an open-source MIT-licensed skill library.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>7. <a href="https://github.com/aquasecurity/trivy" target="_blank" rel="noopener noreferrer">aquasecurity/trivy</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Find vulnerabilities, misconfigurations, secrets, SBOM in containers, Kubernetes, code repositories, clouds and more</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">31,402 stars</span>
                        | <span class="today">25 stars today</span>
                    </p>
                    <p class="history">First seen: February 06, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Trivy is a comprehensive security scanner that detects vulnerabilities, misconfigurations, secrets and produces SBOMs across container images, filesystems, Git repositories, VM images and Kubernetes clusters. It bundles multiple scanners for OS packages and language dependencies, known CVEs, IaC misconfigurations, secret detection and license checks, and supports most popular languages, OSes and platforms. Technically, Trivy is a Go-based CLI and library that inspects artifacts directly (image layers, files, git trees, k8s API), consults vulnerability and SBOM data sources, and emits reports in multiple formats. It runs as a standalone binary or container, integrates with CI/CD and ecosystem tools (GitHub Actions, k8s operator, VS Code), and provides canary builds for rapid iteration.</p>
<p>Trivy is valuable to developers, DevSecOps and security teams who need fast, automated detection of security issues across the software supply chain. Typical use cases include shift-left scanning in CI pipelines, pre-deployment Kubernetes audits, image/VM hardening, repository secret detection and SBOM generation for compliance. Its broad coverage, ease of installation and integration, and active open-source maintenance by Aqua make it attractive for organizations prioritizing supply-chain security. The project is trending because it delivers pragmatic, multi-target scanning and policy-driven automation that fits modern cloud-native workflows.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>8. <a href="https://github.com/fish-shell/fish-shell" target="_blank" rel="noopener noreferrer">fish-shell/fish-shell</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">The user-friendly command line shell.</p>
                    <p class="meta">
                        <span class="language">Rust</span> |
                        <span class="stars">32,416 stars</span>
                        | <span class="today">28 stars today</span>
                    </p>
                    <p class="history">First seen: February 06, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>fish is a smart, user-friendly interactive command-line shell for macOS, Linux and other Unix-like systems (and can be used on Windows via WSL/Cygwin). It provides modern, discoverable features out of the box such as syntax highlighting, inline autosuggestions, rich tab completions, and a web-based fish_config for easy customization. The codebase builds to native binaries and can be compiled with CMake or via Cargo/Rust, with optional dependencies like PCRE2 and gettext; it integrates with standard system utilities and supports automated completion generation from manpages. The project also ships packaged builds, a full test suite, and extensibility points for functions, completions and extra configuration directories used by distributions.</p>
<p>Developers, sysadmins and command-line power users benefit from fish because it reduces setup friction while improving interactivity, discoverability and productivity compared with traditional shells. Casual users gain value from sensible defaults and packaged installers, whereas power users can extend behavior through custom functions, completions and integrations (clipboard, package-name completions, etc.). Its active development, cross-platform support and emphasis on usability and documentation help explain its popularity and ongoing relevance among alternatives like bash and zsh.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>9. <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener noreferrer">nvm-sh/nvm</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions</p>
                    <p class="meta">
                        <span class="language">Shell</span> |
                        <span class="stars">91,395 stars</span>
                        | <span class="today">101 stars today</span>
                    </p>
                    <p class="history">First seen: February 05, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>nvm is a POSIX-compliant bash script that lets users install, manage, and switch between multiple Node.js versions per shell and per user. It works by cloning the project into an NVMDIR (default ~/.nvm), adding a small shell snippet that sources nvm.sh into your shell profile, and exposing commands like nvm install, nvm use, and automatic .nvmrc support to select versions. The installer supports git/curl/wget, environment overrides (NVMDIR, PROFILE, NVMSOURCE), mirrors, Docker/CI non-interactive setups via BASH_ENV, and deeper shell integrations for bash, zsh, and others. Because it’s implemented as a shell script, it runs on any POSIX shell (including WSL) without binary dependencies and manipulates PATH and symlinks to switch active node/npm versions.</p>
<p>This project is valuable for developers, CI/CD engineers, and teams who need reproducible, per-project Node.js environments and easy switching between LTS or experimental releases. It removes friction from working across projects that require different Node versions, aids migration of global packages during installs, and integrates into Docker builds and automated pipelines, making it useful for both local development and build systems. Its wide adoption, simple installer, portability across platforms, and active maintenance explain its popularity and ongoing relevance in the JavaScript ecosystem.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>10. <a href="https://github.com/linshenkx/prompt-optimizer" target="_blank" rel="noopener noreferrer">linshenkx/prompt-optimizer</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">一款提示词优化器，助力于编写高质量的提示词</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">19,451 stars</span>
                        | <span class="today">51 stars today</span>
                    </p>
                    <p class="history">First seen: February 06, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Prompt Optimizer is a cross-platform tool for improving AI prompts to boost the quality and consistency of LLM and image-model outputs. Its core features include one-click intelligent optimization with iterative refinement, separate system/user prompt modes, real-time A/B comparison, multi-model support (OpenAI, Gemini, DeepSeek, Zhipu, SiliconFlow, custom), T2I/I2I image generation, and advanced testing capabilities like context-variable management, multi-turn simulation and Function Calling. Technically it is implemented as a pure front-end application that stores data locally and talks directly to model providers via configurable API keys, with Web, desktop, Chrome extension and Docker deployment options; it also exposes an MCP server for integration with MCP-compatible clients (e.g., Claude Desktop). Desktop builds and Docker help avoid browser CORS/mixed-content issues and enable direct connection to local models and self-hosted APIs.</p>
<p>The project is valuable for prompt engineers, ML practitioners, product teams and creative users who need to iterate, standardize and benchmark prompts across multiple models and modalities (text and images). Its client-side-first privacy model, multi-deployment flexibility (desktop, Docker, Vercel) and MCP compatibility make it practical for organizations that require local model access, reduced data exposure, or integration into existing AI workflows. Given the current proliferation of LLMs, growing emphasis on reproducible prompt engineering, and the need to optimize model cost and accuracy, a focused optimizer with A/B testing, function-calling support and multi-model orchestration is well aligned with market demand.</p>
                    </div>
                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>

<script>
(() => {
    const readKey = "gtd:read_days:gh:v1";
    const dayStr = "2026-02-06";

    let stored = [];
    try {
        stored = JSON.parse(localStorage.getItem(readKey) || "[]");
        if (!Array.isArray(stored)) {
            stored = [];
        }
    } catch (_err) {
        stored = [];
    }

    if (!stored.includes(dayStr)) {
        stored.push(dayStr);
        stored.sort();
        localStorage.setItem(readKey, JSON.stringify(stored));
    }

    const collapseParam = new URLSearchParams(window.location.search).get("collapse_seen");
    const collapseSeen = collapseParam === "0" ? false : true;

    function setCollapsed(repoEl, collapsed) {
        repoEl.classList.toggle("collapsed", collapsed);
        const button = repoEl.querySelector(".repo-toggle");
        if (button) {
            button.textContent = collapsed ? "Show details" : "Hide details";
            button.setAttribute("aria-expanded", String(!collapsed));
        }
    }

    const repos = Array.from(document.querySelectorAll("section.repo[data-seen-before]"));

    repos.forEach((repoEl) => {
        const toggle = repoEl.querySelector(".repo-toggle");
        if (!toggle) {
            return;
        }

        toggle.addEventListener("click", () => {
            setCollapsed(repoEl, !repoEl.classList.contains("collapsed"));
        });
    });

    const collapseBtn = document.getElementById("collapse-seen-btn");
    const expandBtn = document.getElementById("expand-all-btn");

    if (collapseBtn) {
        collapseBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => {
                if (repoEl.dataset.seenBefore === "1") {
                    setCollapsed(repoEl, true);
                }
            });
        });
    }

    if (expandBtn) {
        expandBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => setCollapsed(repoEl, false));
        });
    }

    if (collapseSeen) {
        repos.forEach((repoEl) => {
            if (repoEl.dataset.seenBefore === "1") {
                setCollapsed(repoEl, true);
            }
        });
    }
})();
</script>

</body>
</html>
