<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 17, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 17, 2026</h1>
        <nav>
            <a href="../">&larr; GitHub Calendar</a>
            <a href="../hn/2026-02-17/">Hacker News</a>
        </nav>
    </header>
    <main>
        <div class="repo-controls">
            <button id="collapse-seen-btn" type="button">Collapse Seen Repos</button>
            <button id="expand-all-btn" type="button">Expand All</button>
        </div>
        <article>
            <div class="repos">

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>1. <a href="https://github.com/p-e-w/heretic" target="_blank" rel="noopener noreferrer">p-e-w/heretic</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Fully automatic censorship removal for language models</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">6,729</span>
                        | <span class="today">666 stars today</span>
                    </p>
                    <p class="history">First seen: February 08, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Heretic is a tool for automatically removing censorship (safety alignment) from transformer-based language models by applying directional ablation (aka &quot;abliteration&quot;) combined with a TPE-based parameter optimizer implemented with Optuna. The system automatically searches for abliteration parameters that co-minimize the number of refusals on &quot;harmful&quot; prompts and the KL divergence from the original model on &quot;harmless&quot; prompts, producing decensored models that retain as much capability as possible without costly post-training. It supports most dense and many multimodal and MoE architectures, includes bitsandbytes quantization to reduce VRAM requirements, and provides built-in benchmarking, evaluation, saving/uploading to Hugging Face, and an interactive test/chat option. Optional research features expose interpretability tooling such as PaCMAP projections of residuals, residual-geometry metrics, layer-wise plots, and animations to study how harmful/harmless signals evolve through the network.</p>
<p>Heretic benefits researchers and engineers who want to study or deploy models with fewer safety refusals while preserving original capabilities, as well as hobbyists and operators constrained by GPU memory who can leverage quantization and automatic configuration. It is trending because it automates a previously expert-driven process, reporting abliterations that match or outperform manual efforts on refusal suppression with lower KL damage, and because community-shared decensored models and positive user feedback have driven visibility. Its combination of practical usability, research-focused diagnostics, and competitive empirical results makes it attractive to both the interpretability community and practitioners seeking controllable model behavior.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>2. <a href="https://github.com/seerr-team/seerr" target="_blank" rel="noopener noreferrer">seerr-team/seerr</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Open-source media request and discovery manager for Jellyfin, Plex, and Emby.</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">9,177</span>
                        | <span class="today">283 stars today</span>
                    </p>
                    <p class="history">First seen: February 17, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Seerr is an open-source web application for managing media requests and discovery across Jellyfin, Plex, and Emby. It offers user import/authentication, library scanning, a customizable request UI for movies and TV (including season-level requests), and integrations with Sonarr and Radarr to automate acquisition; it supports PostgreSQL and SQLite backends, SMTP, various notification agents, and exposes an API (docs at http://localhost:5055/api-docs). Technically it runs as a backend service with a mobile-friendly frontend, connects to media servers and automation tools via their APIs, and implements granular permissions, watchlist/blocklist features, and request management stored in the database. The project is community-driven, provides migration guides from Overseerr/Jellyseerr, and includes documentation and contribution guidelines for extensibility.</p>
<p>Seerr delivers clear value to home media server administrators, community hosts, and anyone who accepts content requests by centralizing request intake, simplifying approvals, and automating downstream downloads via Sonarr/Radarr. Itâ€™s especially useful for users migrating from similar projects because of migration aids and for organizations that need role-based access, auditability, and multi-server support across Plex/Jellyfin/Emby. Its open-source development, active community, and frequent feature additions make it a trending choice for self-hosters seeking a polished, extensible request management solution.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>3. <a href="https://github.com/obra/superpowers" target="_blank" rel="noopener noreferrer">obra/superpowers</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">An agentic skills framework &amp; software development methodology that works.</p>
                    <p class="meta">
                        <span class="language">Shell</span> |
                        <span class="stars">53,155</span>
                        | <span class="today">725 stars today</span>
                    </p>
                    <p class="history">First seen: February 04, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Superpowers is a complete software development workflow for coding agents built around composable &quot;skills&quot; and starter instructions that make agents follow a consistent process. Key features include a modular skills library (TDD, systematic debugging, brainstorming, plan-writing, subagent-driven development, code review, and git worktree management), an enforced workflow that moves from spec elicitation to plan to task-level subagents, and a two-stage review system (spec compliance then code quality). Technically it ships as a plugin (Claude Code marketplace) with manual install paths for Codex and OpenCode, stores skills directly in the repository, and has agents fetch and execute skills, spawn subagents per task, and run automated verification and test-driven cycles. The repo also contains contribution guidance and update mechanics so skills can be extended and updated easily.</p>
<p>This project benefits developers, teams, and tool builders who want repeatable, evidence-driven AI-assisted engineeringâ€”especially those who need automated testing, clear task plans, and controlled parallel work via subagents. Itâ€™s gaining traction because it addresses practical pain points in agentic coding (avoiding ad-hoc behavior, enforcing REDâ€‘GREENâ€‘REFACTOR, and integrating with git workflows) while offering an easy integration path for Claude Code and extensibility via an open-source MIT-licensed skill library.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>4. <a href="https://github.com/steipete/gogcli" target="_blank" rel="noopener noreferrer">steipete/gogcli</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Google Suite CLI: Gmail, GCal, GDrive, GContacts.</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">3,712</span>
                        | <span class="today">469 stars today</span>
                    </p>
                    <p class="history">First seen: February 16, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>gogcli is a comprehensive, script-friendly command-line interface for interacting with a wide range of Google services â€” Gmail, Calendar, Drive, Contacts, Classroom, Chat, Sheets, Docs, Slides, Forms, Apps Script, People, Groups, Tasks, and Keep â€” exposing JSON-first output and rich subcommands for searching, sending, uploading, exporting, and managing resources. Technically it is delivered as a single native CLI binary (installable via Homebrew/Arch or built from source) that talks directly to Google REST APIs, supports both OAuth desktop flows and Workspace service-account (domain-wide delegation), and securely stores refresh tokens in OS keyrings or an encrypted keyring. The tool emphasizes least-privilege auth (optional readonly/drive-scope flags), multi-account and multi-client workflows, headless/remote authorization flows, auto-refreshing tokens, and automation-friendly features such as Pub/Sub Gmail watch and an optional Cloudflare Worker backend for email open tracking. Output is designed to be parseable for scripts and automation, with calendar outputs augmented for scripting (e.g., day-of-week fields) and command allowlisting for sandboxed/agent runs.</p>
<p>This project is valuable for power users, developers, SREs, and Workspace administrators who need reproducible, automatable access to Google Workspace services without relying on a browser UI, making it ideal for scripting, cron jobs, CI/CD pipelines, remote servers, and bulk admin tasks. Security and operations-focused features â€” secure credential storage, domain-wide delegation, least-privilege scopes, and multi-account support â€” make it suitable for teams and organizations managing multiple identities and service accounts. Its CLI-first, JSON-oriented design aligns well with modern automation practices and tooling, which helps explain adoption among users who prefer terminal-based workflows or need to integrate Google services into infrastructure-as-code and orchestration systems.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>5. <a href="https://github.com/alibaba/zvec" target="_blank" rel="noopener noreferrer">alibaba/zvec</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">A lightweight, lightning-fast, in-process vector database</p>
                    <p class="meta">
                        <span class="language">C++</span> |
                        <span class="stars">4,226</span>
                        | <span class="today">1,473 stars today</span>
                    </p>
                    <p class="history">First seen: February 15, 2026 | Consecutive daily streak: 3 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Zvec is an open-source, in-process vector database that embeds Alibabaâ€™s Proxima vector search engine to provide low-latency, production-grade similarity search directly inside applications. Its main features include millisecond searches over billions of vectors, native support for dense and sparse embeddings, multi-vector queries, hybrid search combining semantic similarity with structured filters, and simple collection/vector schema APIs. Technically it runs as a library (no separate server) with Python and Node.js clients, letting you create/open collections, insert documents with vectors, and execute VectorQuery-based searches; it supports Linux and macOS on x86_64 and ARM64 and can be installed via pip/npm or built from source. The README emphasizes speed, minimal setup, and scalability driven by the underlying Proxima engine.</p>
<p>Zvec is valuable for teams and developers building semantic search, recommendation systems, retrieval-augmented generation (RAG) for LLMs, personalization, and edge or embedded applications that require low-latency similarity lookups without deploying external services. ML engineers, product teams, and startups benefit from its simplicity and in-process model because it reduces operational overhead while supporting hybrid queries that combine semantic relevance with structured filters for production use cases. Its focus on performance, multi-vector and dense+sparse support, and easy integration make it well-suited to the current surge in embedding-based workflows and generative AI, which is driving adoption of lightweight, high-performance vector stores.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>6. <a href="https://github.com/openclaw/openclaw" target="_blank" rel="noopener noreferrer">openclaw/openclaw</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Your own personal AI assistant. Any OS. Any Platform. The lobster way. ðŸ¦ž</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">203,525</span>
                        | <span class="today">4,201 stars today</span>
                    </p>
                    <p class="history">First seen: February 02, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>OpenClaw is a local-first personal AI assistant platform that you run on your own devices to answer and act across the messaging surfaces you already use (WhatsApp, Telegram, Slack, Discord, Google Chat, Signal, iMessage/BlueBubbles, Teams, Matrix, Zalo, WebChat, etc.). Technically it centers on a Gateway control plane (WS API) that coordinates per-agent sessions, a CLI onboarding wizard and daemon, Pi-style agent runtimes, and companion nodes/apps for macOS, iOS and Android. It integrates model auth/failover (Anthropic/OpenAI and others), a media pipeline, browser control, Canvas/A2UI for visual workspaces, and first-class tools (cron, sessions, nodes, actions) with security defaults for DM handling. Installation and development target Node â‰¥22 with npm/pnpm/bun, plus optional Tailscale exposure and declarative Nix/Docker deployment paths.</p>
<p>This project is valuable for privacy-conscious individuals, power users, and teams who want a single always-on assistant that integrates messaging, voice, browser automation, and custom skills while keeping control of data and models. Use cases include personal productivity across channels, automated ops and alerts, multi-agent routing for complex workflows, and local voice/Canvas-driven interactions on desktop and mobile. Itâ€™s trending because it combines open-source extensibility with multi-channel reach and the rising demand for private, long-context AI assistants that can orchestrate tools and devices rather than just chat.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>7. <a href="https://github.com/SynkraAI/aios-core" target="_blank" rel="noopener noreferrer">SynkraAI/aios-core</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Synkra AIOS: AI-Orchestrated System for Full Stack Development - Core Framework v4.0</p>
                    <p class="meta">
                        <span class="language">JavaScript</span> |
                        <span class="stars">1,068</span>
                        | <span class="today">194 stars today</span>
                    </p>
                    <p class="history">First seen: February 14, 2026 | Consecutive daily streak: 4 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Synkra AIOS is a CLI-first framework that orchestrates specialized AI agents to automate fullâ€‘stack development workflows, providing a core runtime and tooling (v4.0) for planning, development and observability. Its main features include dedicated agent roles (analyst, PM, architect, scrum master, dev, QA), a twoâ€‘phase process that first generates PRDs and architecture then produces hyperâ€‘detailed story files for implementation, lifecycle hooks and IDE integrations, plus observability (SSE dashboards, logs, metrics). Technically it is a Node.js-based toolchain distributed via npx (aios-core CLI), relies on engineered prompts and humanâ€‘inâ€‘theâ€‘loop refinements, file-backed artifacts and hook adapters to integrate with multiple CLIs/IDEs, and provides install/upgrade flows that preserve project customizations.</p>
<p>The project benefits engineering teams, product managers and dev leads who need consistent, context-rich specificationâ€‘toâ€‘code handoffs and stronger automation of repetitive tasks, reducing context loss between planning and implementation. It also suits solo developers and nonâ€‘technical domains (creative writing, business strategy, education) that can leverage domainâ€‘specific agents to scale expertise quickly. Synkra is gaining attention because it combines agent orchestration, reproducible CLIâ€‘first workflows and IDE hook parity to improve developer productivity, governance and observability in AIâ€‘assisted software delivery.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>8. <a href="https://github.com/ashishps1/awesome-system-design-resources" target="_blank" rel="noopener noreferrer">ashishps1/awesome-system-design-resources</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Learn System Design concepts and prepare for interviews using free resources.</p>
                    <p class="meta">
                        <span class="language">Java</span> |
                        <span class="stars">32,590</span>
                        | <span class="today">1,097 stars today</span>
                    </p>
                    <p class="history">First seen: February 17, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository is a curated collection of free system design learning materials and interview preparation aids, organized as a Markdown index (README) for quick navigation. Key features include categorized topic lists (core concepts, networking, APIs, databases, caching, async, distributed systems, architectural patterns, and tradeoffs), graded design problems (easy/medium/hard), and curated courses, books, videos, articles, and seminal research papers. Technically it works by consolidating links and study pathways in a single document, with added calls-to-action like the AlgoMaster newsletter that offers a complimentary interview handbook. The layout is intended for self-directed learning and rapid access to high-value resources.</p>
<p>Software engineers, SDE candidates, interviewers, and CS students benefit most because the repo maps essential theory to practical design problems and prioritizes study topics for interviews. Its structured, graded problems and broad coverage make it easy to prepare systematically for system design interviews and to fill knowledge gaps in distributed system architecture. The project is trending due to sustained demand for scalable, cloud-native design skills in hiring processes and the community preference for centralized, free, curated learning resources. Inclusion of popular books, channels, and canonical research papers increases its visibility and utility.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>9. <a href="https://github.com/steipete/summarize" target="_blank" rel="noopener noreferrer">steipete/summarize</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Point at any URL/YouTube/Podcast or file. Get the gist. CLI and Chrome Extension.</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">3,243</span>
                        | <span class="today">117 stars today</span>
                    </p>
                    <p class="history">First seen: February 17, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Summarize is a combined CLI and browser-side extension that extracts and condenses content from URLs, local files, and media (web pages, PDFs, images, audio/video, YouTube, podcasts, RSS) into concise summaries or structured Markdown/JSON outputs. Key features include slide extraction with screenshots and OCR, transcript-first media handling with Whisper fallback, streaming agent output with metrics and cache-aware status, and multiple output modes (text, JSON, extract-only, timing, cost estimates). Technically it runs as a CLI and an optional local daemon used by the Chrome Side Panel/Firefox Sidebar for heavy extraction (yt-dlp, ffmpeg, tesseract) and streaming; it sends content to configurable model endpoints (local, paid providers, or free OpenRouter presets) and supports provider-aware behavior for media/file types and streaming capabilities.</p>
<p>This project benefits researchers, journalists, knowledge workers, students, and developers who need fast, multimodal content distillation and timestamped media navigation (e.g., slide cards for videos) directly in the browser or terminal. Itâ€™s gaining traction because it integrates modern multimodal LLM workflows with practical local tooling for privacy and performance, offers streaming/interactive summaries in a browser side panel, and is flexible across providers and deployment styles (npm, Homebrew, daemon), making it easy to adopt for both casual and power users.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>10. <a href="https://github.com/hummingbot/hummingbot" target="_blank" rel="noopener noreferrer">hummingbot/hummingbot</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Open source software that helps you create and deploy high-frequency crypto trading bots</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">16,795</span>
                        | <span class="today">565 stars today</span>
                    </p>
                    <p class="history">First seen: February 17, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Hummingbot is an open-source framework for designing, testing, and deploying automated crypto trading strategies across centralized and decentralized exchanges. It provides a modular architecture with standardized connectors for CLOB CEX, CLOB DEX, and AMM DEX venues, built-in strategy templates (e.g., market making and arbitrage), and a Gateway middleware to interact with AMM DEXs. Technically it is a Docker-friendly, Python-based CLI application (with Gateway in TypeScript for certain DEX integrations), communicates via REST and WebSocket APIs, supports install-from-source for development, and is distributed under the Apache 2.0 license.</p>
<p>The project is valuable for algorithmic traders, market makers, liquidity providers, researchers, and developers who need multi-venue automation, rapid connector reuse, and reproducible deployment workflows. By standardizing exchange integrations and offering backtesting, deployment, and community-maintained connectors, it reduces engineering overhead for cross-exchange strategies and on-chain/off-chain workflows. Its tractionâ€”over $34B in reported user trading volume and active open-source governanceâ€”makes it especially attractive as a collaborative platform for building and scaling crypto trading infrastructure.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>11. <a href="https://github.com/anthropics/claude-quickstarts" target="_blank" rel="noopener noreferrer">anthropics/claude-quickstarts</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">A collection of projects designed to help developers quickly get started with building deployable applications using the Claude API</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">14,290</span>
                        | <span class="today">102 stars today</span>
                    </p>
                    <p class="history">First seen: February 17, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Claude Quickstarts is a curated collection of ready-to-run example projects that demonstrate how to build deployable applications using the Claude API. Key features include specialized demos such as a customer support agent with knowledge-base access, a financial data analyst with interactive visualizations, a computer control demo using the computeruse20251124 tool, a browser automation reference using Playwright, and an autonomous two-agent coding system that persists progress via git. Technically, each quickstart wraps Claude API calls and tool integrations (browser DOM actions, system control tools, visualization libraries, and the Claude Agent SDK) into small apps with environment-driven configuration and per-project README/setup instructions. The repo is designed for extension and customization, so developers can swap in their own data sources, tools, and deployment workflows.</p>
<p>This repository is ideal for developers, AI engineers, product teams, and researchers who want production-oriented examples for building LLM-powered applications quickly. It lowers the barrier to adoption by providing runnable patterns for common application types (support bots, analytics, automation, autonomous agents) and showcases practical tool integrations that are in demand. The project is trending because it packages end-to-end, reproducible demos for modern LLM toolchainsâ€”covering automation, browser interaction, and agentic workflowsâ€”under an MIT license and within the growing Anthropic/Claude ecosystem.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>12. <a href="https://github.com/davila7/claude-code-templates" target="_blank" rel="noopener noreferrer">davila7/claude-code-templates</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">CLI tool for configuring and monitoring Claude Code</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">20,607</span>
                        | <span class="today">110 stars today</span>
                    </p>
                    <p class="history">First seen: February 17, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository provides a CLI tool and curated catalog of ready-to-use configurations and templates for Anthropicâ€™s Claude Code, covering agents, custom commands, settings, hooks, MCP (external integrations), and project templates. Key features include oneâ€‘click installation via npx, an interactive browser to explore 100+ components, live analytics and conversation monitoring, health checks, and a plugin dashboard. Technically, the package is distributed as an npm/executable CLI that fetches and installs component definitions into a Claude Code environment, wires external MCP integrations (GitHub, PostgreSQL, AWS, Stripe, etc.), and can optionally expose remote UIs (e.g., via Cloudflare Tunnel). The repo aggregates official and community skills under permissive licenses and structures reusable skills and hooks to accelerate agent-based development.</p>
<p>Developers, AI platform engineers, and teams building LLM-driven tooling benefit most, since they can rapidly provision role-specific agents, CI hooks, and external integrations without writing boilerplate. Product managers and SREs gain value from the analytics, health checks, and realâ€‘time conversation monitor to observe performance and troubleshoot issues. Itâ€™s trending because of rising demand for agentized workflows, the low friction of npx-driven installs, broad community contributions, and the interoperability of MCPs that make adopting and iterating on Claude-based automation fast and practical. Comprehensive documentation and an active community further accelerate adoption and visibility.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>13. <a href="https://github.com/OpenCTI-Platform/opencti" target="_blank" rel="noopener noreferrer">OpenCTI-Platform/opencti</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Open Cyber Threat Intelligence Platform</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">8,260</span>
                        | <span class="today">13 stars today</span>
                    </p>
                    <p class="history">First seen: February 17, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>OpenCTI is an open-source cyber threat intelligence platform that helps organizations structure, store, link, and visualize both technical (TTPs, observables) and non-technical (attribution, victimology) threat information using a knowledge schema based on STIX2. Key features include a GraphQL API, a UX-oriented web frontend, import/export capabilities (CSV, STIX2 bundles), automated relation inference, and connectors to tools like MISP, TheHive and MITRE ATT&amp;CK, with optional Enterprise-only features. Technically it is a modern web application deployable via Docker, Helm, Terraform or manual install, integrates external services such as OpenStreetMap for mapping, and collects anonymous telemetry to improve the platform.</p>
<p>Security operations centers, threat intelligence teams, incident responders, and MSSPs benefit from OpenCTI because it centralizes diverse intelligence sources, enforces structured schemas, links artifacts to primary sources, and streamlines analysis and sharing across tools. It is trending due to strong STIX2 interoperability, a developer-friendly GraphQL API, a growing ecosystem of connectors, active community and enterprise development, and straightforward deployment/demo options that lower adoption barriers. The projectâ€™s open-source nature, extensibility, and focus on inference and visualization make it appealing for organizations building automated, collaborative CTI workflows.</p>
                    </div>
                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>

<script>
(() => {
    const readKey = "gtd:read_days:gh:v1";
    const dayStr = "2026-02-17";

    let stored = [];
    try {
        stored = JSON.parse(localStorage.getItem(readKey) || "[]");
        if (!Array.isArray(stored)) {
            stored = [];
        }
    } catch (_err) {
        stored = [];
    }

    if (!stored.includes(dayStr)) {
        stored.push(dayStr);
        stored.sort();
        localStorage.setItem(readKey, JSON.stringify(stored));
    }

    const collapseSeen = new URLSearchParams(window.location.search).get("collapse_seen") === "1";

    function setCollapsed(repoEl, collapsed) {
        repoEl.classList.toggle("collapsed", collapsed);
        const button = repoEl.querySelector(".repo-toggle");
        if (button) {
            button.textContent = collapsed ? "Show details" : "Hide details";
            button.setAttribute("aria-expanded", String(!collapsed));
        }
    }

    const repos = Array.from(document.querySelectorAll("section.repo[data-seen-before]"));

    repos.forEach((repoEl) => {
        const toggle = repoEl.querySelector(".repo-toggle");
        if (!toggle) {
            return;
        }

        toggle.addEventListener("click", () => {
            setCollapsed(repoEl, !repoEl.classList.contains("collapsed"));
        });
    });

    const collapseBtn = document.getElementById("collapse-seen-btn");
    const expandBtn = document.getElementById("expand-all-btn");

    if (collapseBtn) {
        collapseBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => {
                if (repoEl.dataset.seenBefore === "1") {
                    setCollapsed(repoEl, true);
                }
            });
        });
    }

    if (expandBtn) {
        expandBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => setCollapsed(repoEl, false));
        });
    }

    if (collapseSeen) {
        repos.forEach((repoEl) => {
            if (repoEl.dataset.seenBefore === "1") {
                setCollapsed(repoEl, true);
            }
        });
    }
})();
</script>

</body>
</html>
