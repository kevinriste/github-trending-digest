<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 16, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 16, 2026</h1>
        <nav>
            <a href="../">&larr; Back to Calendar</a>
        </nav>
    </header>
    <main>
        <article>
            <div class="repos">

            <section class="repo">
                <h3>1. <a href="https://github.com/nautechsystems/nautilus_trader" target="_blank">nautechsystems/nautilus_trader</a></h3>
                <p class="description">A high-performance algorithmic trading platform and event-driven backtester</p>
                <p class="meta">
                    <span class="language">Rust</span> |
                    <span class="stars">19,415 stars</span>
                    | <span class="today">68 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>NautilusTrader is an open-source, event-driven algorithmic trading platform and high-performance backtester that lets users run identical strategy code in both historical simulations and live deployments. It supports multi-venue, multi-asset workflows (FX, equities, futures, options, crypto, DeFi, betting) with nanosecond-resolution ticks, advanced order types and contingency logic, and optional Redis-backed state persistence. The core is implemented in Rust for speed, safety and async networking (tokio), with Python-native bindings provided via Cython/PyO3 so traders can write strategies in Python while leveraging native binaries. Modular adapters translate REST/WebSocket venue APIs into a normalized domain model, enabling flexible integration and deployment (Docker-ready).</p>
<p>This project is valuable for quantitative traders, prop shops, HFT teams, and researchers who need production-grade parity between research and live trading, low-latency execution, and robust risk controls. It is particularly attractive for teams training AI agents (RL/ES) because the backtest engine is designed to be fast enough for model training and experimentation while preserving real-world event semantics. The combination of Python usability and Rust-powered performance/safety, plus modular adapters for many venues, explains its relevance as firms seek reproducible, extensible, and high-throughput trading infrastructure.</p>

                </div>
            </section>

            <section class="repo">
                <h3>2. <a href="https://github.com/steipete/gogcli" target="_blank">steipete/gogcli</a></h3>
                <p class="description">Google Suite CLI: Gmail, GCal, GDrive, GContacts.</p>
                <p class="meta">
                    <span class="language">Go</span> |
                    <span class="stars">3,106 stars</span>
                    | <span class="today">630 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>gogcli (gog) is a fast, script-friendly command-line interface that exposes a wide range of Google Workspace and consumer APIs (Gmail, Calendar, Drive, Contacts, Chat, Classroom, Sheets, Docs/Slides/Forms, Apps Script, Tasks, People, Groups, Keep, etc.) with JSON-first output and rich operations such as searching, sending, uploading/downloading, permission management, event handling, and exports. It supports multiple accounts and OAuth clients, least-privilege scoping, Workspace service-account (domain‚Äëwide) delegation, and special flows for headless or remote servers. Tokens and credentials are stored securely (OS keyring or encrypted on-disk keyring), tokens auto-refresh, and the tool includes automation-friendly features like a command allowlist and Gmail Pub/Sub watch integration. The project is distributed as a Go-built binary with parseable output intended for scripting and integration into automation pipelines.</p>
<p>This tool is useful for developers, sysadmins, SREs, and power users who need to automate Google API tasks from terminals, CI/CD systems, or headless servers without using web UIs. Its JSON output, multi-account support, and auth flexibility make it well-suited for reproducible scripts, migrations, administrative workflows, scheduled jobs, and integrations with other tools. Workspace administrators gain value from domain-wide delegation, group and directory management, and granular scope control, while security-conscious users benefit from keyring-backed credential storage and least-privilege modes. The broad API coverage and machine-friendly design explain its appeal for automation-focused projects and teams.</p>

                </div>
            </section>

            <section class="repo">
                <h3>3. <a href="https://github.com/rowboatlabs/rowboat" target="_blank">rowboatlabs/rowboat</a></h3>
                <p class="description">Open-source AI coworker, with memory</p>
                <p class="meta">
                    <span class="language">TypeScript</span> |
                    <span class="stars">6,924 stars</span>
                    | <span class="today">803 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Rowboat is an open-source, local-first AI coworker that turns your emails, meeting notes, and other work artifacts into an Obsidian-compatible Markdown knowledge graph and uses that persistent context to draft emails, generate briefs and decks, summarize meetings, record voice memos, and run background agents. Technically it stores a plain Markdown vault with backlinks on your machine, connects to data sources like Gmail/meeting services, optionally uses Deepgram for transcription and Brave/Exa for web search, and interfaces with local or hosted LLMs (Ollama, LM Studio, or API providers). It exposes editable, inspectable memory and supports extensibility via the Model Context Protocol (MCP) to plug in search, CRMs, automations, and other tools while keeping control of data locally.</p>
<p>Rowboat is valuable for knowledge workers, product and engineering teams, executives, and anyone who needs better meeting prep, grounded email drafting, recurring project updates, or automated follow-ups because it reduces context rebuilding and captures decisions and action items over time. Its local-first design, editable long-lived memory, and ability to bring-your-own model make it attractive for organizations concerned about privacy, data control, and auditability, and its background agents and tool integrations help automate routine workflows‚Äîexplaining why similar memory-centric AI assistants are trending.</p>

                </div>
            </section>

            <section class="repo">
                <h3>4. <a href="https://github.com/github/gh-aw" target="_blank">github/gh-aw</a></h3>
                <p class="description">GitHub Agentic Workflows</p>
                <p class="meta">
                    <span class="language">Go</span> |
                    <span class="stars">2,769 stars</span>
                    | <span class="today">213 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>GitHub Agentic Workflows lets you describe agentic workflows in natural-language Markdown and execute them inside GitHub Actions, effectively combining Actions, autonomous agents, and built-in safety. Its main features include a Quick Start, workflow types and examples, Peli‚Äôs Agent Factory guided library, and extensive guardrails such as read-only-by-default run contexts, sanitized safe-outputs for writes, sandboxed execution, network isolation, SHA-pinned dependencies, tool allow-listing, compile-time validation, and human approval gates. Technically, the system parses Markdown workflows into actionable steps that invoke models and tools through controlled interfaces, with companion components like the AWF for egress control and the MCP Gateway for routed model calls to enforce policy and observability. The design emphasizes multilayered security and supply-chain protections so autonomous actions can be audited and constrained within repository CI/CD.</p>
<p>This project is valuable for developer teams, platform engineers, and security/DevOps groups who want to automate repository tasks‚Äîsuch as issue triage, code generation, dependency updates, and release orchestration‚Äîwhile maintaining rigorous safety and auditability. Organizations that need reproducible, policy-driven automation with human-in-the-loop approvals will benefit from the guardrails and enterprise-friendly controls. It‚Äôs trending because of the rapid adoption of LLM-driven agents to augment developer workflows and the demand for tightly integrated, secure automation within GitHub‚Äôs ecosystem. The combination of agentic convenience and explicit safety mechanisms makes it attractive for teams exploring trustworthy AI-assisted CI/CD.</p>

                </div>
            </section>

            <section class="repo">
                <h3>5. <a href="https://github.com/ChromeDevTools/chrome-devtools-mcp" target="_blank">ChromeDevTools/chrome-devtools-mcp</a></h3>
                <p class="description">Chrome DevTools for coding agents</p>
                <p class="meta">
                    <span class="language">TypeScript</span> |
                    <span class="stars">25,495 stars</span>
                    | <span class="today">357 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Chrome DevTools MCP is an MCP (Model‚ÄëContext‚ÄëProtocol) server that lets AI coding agents (e.g., Gemini, Claude, Cursor, Copilot) control and inspect a live Chrome browser by exposing Chrome DevTools functionality. Its main features include recording and analyzing performance traces, network request inspection, screenshots, console messages with source‚Äëmapped stack traces, and reliable automation driven by puppeteer with automatic waits. Technically it runs as a local Node.js process (distributed via npx), attaches to or launches a Chrome instance over the remote debugging protocol, and exposes DevTools APIs and optional ‚Äúskills‚Äù to MCP clients; it can also augment lab traces with CrUX field data and collects usage statistics by default (opt‚Äëout available).</p>
<p>This project is valuable for engineers and platform builders who want to integrate deep browser automation, debugging, and performance analysis into LLM-driven workflows‚Äîuse cases include automated bug reproduction, performance audits, QA test automation, and assistive developer tooling. Teams building AI assistants, SRE/performance teams, QA engineers, and tool integrators benefit because MCP enables standardized, programmatic access to the full power of DevTools from agents, improving reliability and observability of automated tasks. Its relevance is rising as more developer tooling adopts agent-based workflows and MCP-style integrations to let models perform actionable, context-aware operations in real browsers.</p>

                </div>
            </section>

            <section class="repo">
                <h3>6. <a href="https://github.com/alibaba/zvec" target="_blank">alibaba/zvec</a></h3>
                <p class="description">A lightweight, lightning-fast, in-process vector database</p>
                <p class="meta">
                    <span class="language">C++</span> |
                    <span class="stars">2,510 stars</span>
                    | <span class="today">673 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Zvec is an open-source, in-process vector database that embeds directly into applications to provide low-latency similarity search. Its main features include blazing-fast similarity search over billions of vectors, native support for dense and sparse embeddings, multi-vector queries, hybrid search with structured filters, and minimal setup across Python and Node.js clients. Technically, Zvec is built on Alibaba‚Äôs Proxima search engine and exposes a lightweight collection/schema API (e.g., FP32 vectors) for local indexing and querying, enabling high-performance nearest-neighbor search without separate server infrastructure. It supports common platforms (Linux x86_64/ARM64, macOS ARM64) and can be built from source for customized deployments.</p>
<p>Zvec is valuable for developers and teams that need to add semantic search, recommendations, or retrieval-augmented generation (RAG) to applications with minimal ops overhead, such as web services, desktop tools, notebooks, and edge devices. Its in-process nature and small footprint make it particularly appealing for latency-sensitive production systems and environments where running and operating a separate vector server is impractical. Organizations building search, personalization, or AI augmentation features will benefit from its scalability, speed, and hybrid filtering capabilities. The project is trending because demand for embedding-based similarity search has surged with the rise of LLMs and vectorized AI workflows, driving interest in lightweight, easy-to-integrate solutions.</p>

                </div>
            </section>

            <section class="repo">
                <h3>7. <a href="https://github.com/openclaw/openclaw" target="_blank">openclaw/openclaw</a></h3>
                <p class="description">Your own personal AI assistant. Any OS. Any Platform. The lobster way. ü¶û</p>
                <p class="meta">
                    <span class="language">TypeScript</span> |
                    <span class="stars">198,214 stars</span>
                    | <span class="today">2,380 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>OpenClaw is a self‚Äëhosted personal AI assistant that runs on your own devices and connects to the messaging channels you already use (WhatsApp, Telegram, Slack, Discord, Google Chat, Signal, iMessage/BlueBubbles, Microsoft Teams, WebChat, Zalo, Matrix, etc.), plus companion macOS/iOS/Android nodes, voice I/O, and a live Canvas visual workspace. Technically it is built around a Gateway control plane (a WebSocket daemon) that manages sessions, presence, agents, tools, and channel integrations while agent runtimes (including optional Pi agents) execute skills and stream responses; models are pluggable with auth/profile rotation, failover, and recommendations (Anthropic/OpenAI). The bundle includes first‚Äëclass tooling‚Äîbrowser automation, A2UI Canvas, cron, media pipeline, and tool streaming‚Äîalong with a CLI onboarding wizard, daemon install, and security defaults like DM pairing and allowlists. The codebase targets Node ‚â•22 (TypeScript), supports npm/pnpm/bun workflows, and provides a development loop and packaging for local or remote exposure (Tailscale/Serve or SSH).</p>
<p>OpenClaw‚Äôs value is strongest for privacy‚Äëconscious individuals, power users, and small teams who need an always‚Äëon, extensible assistant that keeps control and data local while integrating with existing chat platforms and devices. It fits use cases from personal automation and multi‚Äëchannel inbox management to voice‚Äëdriven companions, browser‚Äëassisted research, and developer toolchains that chain actions and long‚Äëcontext models. The platform‚Äôs model failover, skills system, security controls, and remote access options (Tailscale/Funnel) make it useful for production‚Äëoriented hobbyists and organizations that require reliability and explicit control, which explains its traction among self‚Äëhosted and privacy‚Äëfocused communities.</p>

                </div>
            </section>

            <section class="repo">
                <h3>8. <a href="https://github.com/moonshine-ai/moonshine" target="_blank">moonshine-ai/moonshine</a></h3>
                <p class="description">Fast and accurate automatic speech recognition (ASR) for edge devices</p>
                <p class="meta">
                    <span class="language">C</span> |
                    <span class="stars">3,913 stars</span>
                    | <span class="today">157 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Moonshine Voice is an open-source AI toolkit for building real-time, on-device automatic speech recognition and voice interfaces. Its main features include low-latency streaming models optimized for live transcription, speaker diarization, and intent/command recognition, with models ranging from tiny (‚âà26 MB) to larger, production-grade sizes trained from scratch and supporting multiple languages. Technically it avoids Whisper‚Äôs fixed 30-second window and redundant reprocessing by using streaming architectures and caching so computation is done incrementally while the user is still talking, yielding much lower latency and smaller parameter counts. Cross-platform libraries and examples (Python, C++/cmake, iOS, Android, macOS, Windows, Raspberry Pi) make deployment on a wide range of edge devices straightforward.</p>
<p>This project is valuable for developers and product teams who need responsive, private, offline voice interfaces on mobile, IoT, wearables, and other constrained hardware. It enables use cases such as hands-free controls, real-time transcription, command recognition, and accessibility features where latency, privacy, and power/size constraints are critical. Moonshine is gaining traction because of growing demand for on-device AI, the limitations of batch-oriented models like Whisper for streaming applications, and the appeal of a unified, optimized toolkit for heterogeneous edge platforms.</p>

                </div>
            </section>

            <section class="repo">
                <h3>9. <a href="https://github.com/brave/brave-browser" target="_blank">brave/brave-browser</a></h3>
                <p class="description">Brave browser for Android, iOS, Linux, macOS, Windows.</p>
                <p class="meta">
                    <span class="language">Unknown</span> |
                    <span class="stars">21,593 stars</span>
                    | <span class="today">27 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>This repository provides the build and orchestration tooling required to fetch, patch, and compile the Brave desktop browser for macOS, Windows, and Linux. It coordinates upstream components (notably Chromium via depot_tools) and the brave-core source mounted at src/brave, applies maintained patches, and links additional components such as the adblock-rust engine through an FFI layer. Build and sync workflows are driven by npm scripts (init, build, sync, apply_patches) and gclient/DEPS configuration, with support for component, Release, Static, and Debug build configurations and cross-platform targets. The tooling automates dependency updates, patch application, and hooks to produce reproducible Brave builds from source.</p>
<p>The project is valuable to Brave developers, open-source contributors, downstream packagers, security auditors, and organizations that need to build or inspect a privacy-focused Chromium derivative. It enables reproducible, auditable builds and makes it easier to maintain Brave-specific patches and privacy features (ad blocking, Safe Browsing integration, etc.), which appeals to users and communities prioritizing privacy and control. Because it combines Chromium compatibility with Brave‚Äôs privacy-first features and a Rust-based ad-block engine, it attracts interest from developers and privacy-conscious users alike, helping explain its ongoing relevance and adoption.</p>

                </div>
            </section>

            <section class="repo">
                <h3>10. <a href="https://github.com/SynkraAI/aios-core" target="_blank">SynkraAI/aios-core</a></h3>
                <p class="description">Synkra AIOS: AI-Orchestrated System for Full Stack Development - Core Framework v4.0</p>
                <p class="meta">
                    <span class="language">JavaScript</span> |
                    <span class="stars">827 stars</span>
                    | <span class="today">163 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Synkra AIOS is a CLI-first, agent-oriented framework that orchestrates AI agents to drive end-to-end product planning and full-stack development. Its core features include specialized agent roles (analyst, PM, architect, scrum master, dev, QA), a two-phase workflow that separates agentic planning (PRD and architecture generation) from contextualized development (story files with embedded implementation guidance), observability via dashboards/logs, and multi-IDE lifecycle hook integrations. Technically it is distributed as a Node.js/npm tool (npx aios-core) that relies on advanced prompt engineering, human-in-the-loop refinement, and self-modifying workflows to maintain context across sessions and agents; install/update commands preserve customizations and create backups. The design emphasizes CLI control as the source of truth while providing optional UI and integration layers for IDEs and monitoring.</p>
<p>The project is valuable for engineering teams and organizations aiming to systematize AI-assisted software delivery, product managers who want consistent PRDs and architecture artifacts, and solo developers or non-technical users who need domain-specific agent squads for tasks beyond coding (writing, business strategy, education). By reducing planning inconsistencies and preventing context loss between planning and implementation, it streamlines Agile workflows and automates routine orchestration tasks, speeding delivery and improving auditability. Its timing reflects rising interest in agent-based LLM workflows, richer IDE integrations, and demand for reproducible, observable AI tooling, and it is extensible for teams that want to build custom agents or cross-domain squads.</p>

                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>
</body>
</html>
