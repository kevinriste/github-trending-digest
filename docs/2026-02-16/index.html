<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 16, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 16, 2026</h1>
        <nav>
            <a href="../">&larr; GitHub Calendar</a>
            <a href="../hn/">Hacker News</a>
        </nav>
    </header>
    <main>
        <div class="repo-controls">
            <button id="collapse-seen-btn" type="button">Collapse Seen Repos</button>
            <button id="expand-all-btn" type="button">Expand All</button>
        </div>
        <article>
            <div class="repos">

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>1. <a href="https://github.com/nautechsystems/nautilus_trader" target="_blank" rel="noopener noreferrer">nautechsystems/nautilus_trader</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">A high-performance algorithmic trading platform and event-driven backtester</p>
                    <p class="meta">
                        <span class="language">Rust</span> |
                        <span class="stars">19,415 stars</span>
                        | <span class="today">68 stars today</span>
                    </p>
                    <p class="history">First seen: February 16, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>NautilusTrader is an open-source, high-performance algorithmic trading platform and event-driven backtester that lets you run identical Python strategy code in both historical simulation and live deployment. Its core components are implemented in Rust (with Cython/PyO3 bindings) for speed and safety, while exposing a Python-native environment for strategy development; the engine supports nanosecond-resolution ticks, multi-venue/multi-asset backtests, advanced order types and contingencies, optional Redis-backed persistence, and modular adapters for REST/WebSocket integrations. The architecture is event-driven and message-bus oriented, enabling granular, low-latency execution and replay of market events with type- and thread-safety guarantees. Designed for production use, it emphasizes correctness, extendability, and parity between research and operations environments.</p>
<p>The platform is valuable for quantitative traders, trading firms, algorithm developers, and researchers who need a production-grade, Python-first system that scales from research to live trading without reimplementation. It is particularly useful for HFT, market-making, statistical arbitrage, and AI training workflows (RL/ES) where performance, low-latency event handling, and reproducible backtests matter. NautilusTrader‚Äôs combination of Rust performance, Python usability, modular adapters, and advanced order logic reduces operational risk and accelerates development and deployment cycles. Its alignment with trends in Python data science and growing Rust adoption makes it attractive for teams seeking modern, safe, and extensible trading infrastructure.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>2. <a href="https://github.com/steipete/gogcli" target="_blank" rel="noopener noreferrer">steipete/gogcli</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Google Suite CLI: Gmail, GCal, GDrive, GContacts.</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">3,106 stars</span>
                        | <span class="today">630 stars today</span>
                    </p>
                    <p class="history">First seen: February 16, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>gogcli is a comprehensive, script-friendly command-line interface for interacting with a wide range of Google services ‚Äî Gmail, Calendar, Drive, Contacts, Classroom, Chat, Sheets, Docs, Slides, Forms, Apps Script, People, Groups, Tasks, and Keep ‚Äî exposing JSON-first output and rich subcommands for searching, sending, uploading, exporting, and managing resources. Technically it is delivered as a single native CLI binary (installable via Homebrew/Arch or built from source) that talks directly to Google REST APIs, supports both OAuth desktop flows and Workspace service-account (domain-wide delegation), and securely stores refresh tokens in OS keyrings or an encrypted keyring. The tool emphasizes least-privilege auth (optional readonly/drive-scope flags), multi-account and multi-client workflows, headless/remote authorization flows, auto-refreshing tokens, and automation-friendly features such as Pub/Sub Gmail watch and an optional Cloudflare Worker backend for email open tracking. Output is designed to be parseable for scripts and automation, with calendar outputs augmented for scripting (e.g., day-of-week fields) and command allowlisting for sandboxed/agent runs.</p>
<p>This project is valuable for power users, developers, SREs, and Workspace administrators who need reproducible, automatable access to Google Workspace services without relying on a browser UI, making it ideal for scripting, cron jobs, CI/CD pipelines, remote servers, and bulk admin tasks. Security and operations-focused features ‚Äî secure credential storage, domain-wide delegation, least-privilege scopes, and multi-account support ‚Äî make it suitable for teams and organizations managing multiple identities and service accounts. Its CLI-first, JSON-oriented design aligns well with modern automation practices and tooling, which helps explain adoption among users who prefer terminal-based workflows or need to integrate Google services into infrastructure-as-code and orchestration systems.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>3. <a href="https://github.com/rowboatlabs/rowboat" target="_blank" rel="noopener noreferrer">rowboatlabs/rowboat</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Open-source AI coworker, with memory</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">6,924 stars</span>
                        | <span class="today">803 stars today</span>
                    </p>
                    <p class="history">First seen: February 13, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Rowboat is an open-source, local-first AI coworker that builds and maintains a long-lived knowledge graph from your email, meeting notes, and other work artifacts to help you summarize, draft, plan, and produce deliverables. It stores memory as an Obsidian-compatible vault of plain Markdown with backlinks so context is transparent, editable, and kept on your machine. Rowboat connects to services like Gmail, Calendar, Drive, meeting transcription tools, and can record voice notes, draft emails, generate PDFs and slides, and run background agents to automate recurring tasks. Technically it supports local and hosted LLMs (Ollama, LM Studio, or API-based providers) and exposes a Model Context Protocol (MCP) to integrate search, databases, and other tools.</p>
<p>The project benefits knowledge workers, product managers, executives, and small teams who need contextual continuity, private data storage, and automated task assistance. By compounding memory rather than reconstructing context each time, Rowboat reduces repetitive work, speeds meeting prep, improves email drafting, and helps capture decisions and action items reliably. Its local-first design, Obsidian compatibility, background agents, and support for local models make it attractive to privacy-conscious users, while MCP-driven extensibility aligns with the current trend toward customizable, interoperable AI assistants.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>4. <a href="https://github.com/github/gh-aw" target="_blank" rel="noopener noreferrer">github/gh-aw</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">GitHub Agentic Workflows</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">2,769 stars</span>
                        | <span class="today">213 stars today</span>
                    </p>
                    <p class="history">First seen: February 10, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>GitHub Agentic Workflows lets you describe agentic workflows in natural-language Markdown and execute them inside GitHub Actions, effectively combining Actions, autonomous agents, and built-in safety. Its main features include a Quick Start, workflow types and examples, Peli‚Äôs Agent Factory guided library, and extensive guardrails such as read-only-by-default run contexts, sanitized safe-outputs for writes, sandboxed execution, network isolation, SHA-pinned dependencies, tool allow-listing, compile-time validation, and human approval gates. Technically, the system parses Markdown workflows into actionable steps that invoke models and tools through controlled interfaces, with companion components like the AWF for egress control and the MCP Gateway for routed model calls to enforce policy and observability. The design emphasizes multilayered security and supply-chain protections so autonomous actions can be audited and constrained within repository CI/CD.</p>
<p>This project is valuable for developer teams, platform engineers, and security/DevOps groups who want to automate repository tasks‚Äîsuch as issue triage, code generation, dependency updates, and release orchestration‚Äîwhile maintaining rigorous safety and auditability. Organizations that need reproducible, policy-driven automation with human-in-the-loop approvals will benefit from the guardrails and enterprise-friendly controls. It‚Äôs trending because of the rapid adoption of LLM-driven agents to augment developer workflows and the demand for tightly integrated, secure automation within GitHub‚Äôs ecosystem. The combination of agentic convenience and explicit safety mechanisms makes it attractive for teams exploring trustworthy AI-assisted CI/CD.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>5. <a href="https://github.com/ChromeDevTools/chrome-devtools-mcp" target="_blank" rel="noopener noreferrer">ChromeDevTools/chrome-devtools-mcp</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Chrome DevTools for coding agents</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">25,495 stars</span>
                        | <span class="today">357 stars today</span>
                    </p>
                    <p class="history">First seen: February 12, 2026 | Consecutive daily streak: 5 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Chrome DevTools MCP is an MCP (Model‚ÄëContext‚ÄëProtocol) server that lets AI coding agents (e.g., Gemini, Claude, Cursor, Copilot) control and inspect a live Chrome browser by exposing Chrome DevTools functionality. Its main features include recording and analyzing performance traces, network request inspection, screenshots, console messages with source‚Äëmapped stack traces, and reliable automation driven by puppeteer with automatic waits. Technically it runs as a local Node.js process (distributed via npx), attaches to or launches a Chrome instance over the remote debugging protocol, and exposes DevTools APIs and optional ‚Äúskills‚Äù to MCP clients; it can also augment lab traces with CrUX field data and collects usage statistics by default (opt‚Äëout available).</p>
<p>This project is valuable for engineers and platform builders who want to integrate deep browser automation, debugging, and performance analysis into LLM-driven workflows‚Äîuse cases include automated bug reproduction, performance audits, QA test automation, and assistive developer tooling. Teams building AI assistants, SRE/performance teams, QA engineers, and tool integrators benefit because MCP enables standardized, programmatic access to the full power of DevTools from agents, improving reliability and observability of automated tasks. Its relevance is rising as more developer tooling adopts agent-based workflows and MCP-style integrations to let models perform actionable, context-aware operations in real browsers.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>6. <a href="https://github.com/alibaba/zvec" target="_blank" rel="noopener noreferrer">alibaba/zvec</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">A lightweight, lightning-fast, in-process vector database</p>
                    <p class="meta">
                        <span class="language">C++</span> |
                        <span class="stars">2,510 stars</span>
                        | <span class="today">673 stars today</span>
                    </p>
                    <p class="history">First seen: February 15, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Zvec is an open-source, in-process vector database that embeds Alibaba‚Äôs Proxima vector search engine to provide low-latency, production-grade similarity search directly inside applications. Its main features include millisecond searches over billions of vectors, native support for dense and sparse embeddings, multi-vector queries, hybrid search combining semantic similarity with structured filters, and simple collection/vector schema APIs. Technically it runs as a library (no separate server) with Python and Node.js clients, letting you create/open collections, insert documents with vectors, and execute VectorQuery-based searches; it supports Linux and macOS on x86_64 and ARM64 and can be installed via pip/npm or built from source. The README emphasizes speed, minimal setup, and scalability driven by the underlying Proxima engine.</p>
<p>Zvec is valuable for teams and developers building semantic search, recommendation systems, retrieval-augmented generation (RAG) for LLMs, personalization, and edge or embedded applications that require low-latency similarity lookups without deploying external services. ML engineers, product teams, and startups benefit from its simplicity and in-process model because it reduces operational overhead while supporting hybrid queries that combine semantic relevance with structured filters for production use cases. Its focus on performance, multi-vector and dense+sparse support, and easy integration make it well-suited to the current surge in embedding-based workflows and generative AI, which is driving adoption of lightweight, high-performance vector stores.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>7. <a href="https://github.com/openclaw/openclaw" target="_blank" rel="noopener noreferrer">openclaw/openclaw</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Your own personal AI assistant. Any OS. Any Platform. The lobster way. ü¶û</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">198,214 stars</span>
                        | <span class="today">2,380 stars today</span>
                    </p>
                    <p class="history">First seen: February 02, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>OpenClaw is a local-first personal AI assistant platform that you run on your own devices to answer and act across the messaging surfaces you already use (WhatsApp, Telegram, Slack, Discord, Google Chat, Signal, iMessage/BlueBubbles, Teams, Matrix, Zalo, WebChat, etc.). Technically it centers on a Gateway control plane (WS API) that coordinates per-agent sessions, a CLI onboarding wizard and daemon, Pi-style agent runtimes, and companion nodes/apps for macOS, iOS and Android. It integrates model auth/failover (Anthropic/OpenAI and others), a media pipeline, browser control, Canvas/A2UI for visual workspaces, and first-class tools (cron, sessions, nodes, actions) with security defaults for DM handling. Installation and development target Node ‚â•22 with npm/pnpm/bun, plus optional Tailscale exposure and declarative Nix/Docker deployment paths.</p>
<p>This project is valuable for privacy-conscious individuals, power users, and teams who want a single always-on assistant that integrates messaging, voice, browser automation, and custom skills while keeping control of data and models. Use cases include personal productivity across channels, automated ops and alerts, multi-agent routing for complex workflows, and local voice/Canvas-driven interactions on desktop and mobile. It‚Äôs trending because it combines open-source extensibility with multi-channel reach and the rising demand for private, long-context AI assistants that can orchestrate tools and devices rather than just chat.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>8. <a href="https://github.com/moonshine-ai/moonshine" target="_blank" rel="noopener noreferrer">moonshine-ai/moonshine</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Fast and accurate automatic speech recognition (ASR) for edge devices</p>
                    <p class="meta">
                        <span class="language">C</span> |
                        <span class="stars">3,913 stars</span>
                        | <span class="today">157 stars today</span>
                    </p>
                    <p class="history">First seen: February 16, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Moonshine Voice is an open-source AI toolkit for building real-time, on-device automatic speech recognition and voice interfaces. Its main features include low-latency streaming models optimized for live transcription, speaker diarization, and intent/command recognition, with models ranging from tiny (‚âà26 MB) to larger, production-grade sizes trained from scratch and supporting multiple languages. Technically it avoids Whisper‚Äôs fixed 30-second window and redundant reprocessing by using streaming architectures and caching so computation is done incrementally while the user is still talking, yielding much lower latency and smaller parameter counts. Cross-platform libraries and examples (Python, C++/cmake, iOS, Android, macOS, Windows, Raspberry Pi) make deployment on a wide range of edge devices straightforward.</p>
<p>This project is valuable for developers and product teams who need responsive, private, offline voice interfaces on mobile, IoT, wearables, and other constrained hardware. It enables use cases such as hands-free controls, real-time transcription, command recognition, and accessibility features where latency, privacy, and power/size constraints are critical. Moonshine is gaining traction because of growing demand for on-device AI, the limitations of batch-oriented models like Whisper for streaming applications, and the appeal of a unified, optimized toolkit for heterogeneous edge platforms.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>9. <a href="https://github.com/brave/brave-browser" target="_blank" rel="noopener noreferrer">brave/brave-browser</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Brave browser for Android, iOS, Linux, macOS, Windows.</p>
                    <p class="meta">
                        <span class="language">Unknown</span> |
                        <span class="stars">21,593 stars</span>
                        | <span class="today">27 stars today</span>
                    </p>
                    <p class="history">First seen: February 16, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository provides the build and orchestration tooling required to fetch, patch, and compile the Brave desktop browser for macOS, Windows, and Linux. It coordinates upstream components (notably Chromium via depot_tools) and the brave-core source mounted at src/brave, applies maintained patches, and links additional components such as the adblock-rust engine through an FFI layer. Build and sync workflows are driven by npm scripts (init, build, sync, apply_patches) and gclient/DEPS configuration, with support for component, Release, Static, and Debug build configurations and cross-platform targets. The tooling automates dependency updates, patch application, and hooks to produce reproducible Brave builds from source.</p>
<p>The project is valuable to Brave developers, open-source contributors, downstream packagers, security auditors, and organizations that need to build or inspect a privacy-focused Chromium derivative. It enables reproducible, auditable builds and makes it easier to maintain Brave-specific patches and privacy features (ad blocking, Safe Browsing integration, etc.), which appeals to users and communities prioritizing privacy and control. Because it combines Chromium compatibility with Brave‚Äôs privacy-first features and a Rust-based ad-block engine, it attracts interest from developers and privacy-conscious users alike, helping explain its ongoing relevance and adoption.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>10. <a href="https://github.com/SynkraAI/aios-core" target="_blank" rel="noopener noreferrer">SynkraAI/aios-core</a> <span class="seen-badge">Seen before</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Synkra AIOS: AI-Orchestrated System for Full Stack Development - Core Framework v4.0</p>
                    <p class="meta">
                        <span class="language">JavaScript</span> |
                        <span class="stars">827 stars</span>
                        | <span class="today">163 stars today</span>
                    </p>
                    <p class="history">First seen: February 14, 2026 | Consecutive daily streak: 3 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Synkra AIOS is a CLI-first framework that orchestrates specialized AI agents to automate full‚Äëstack development workflows, providing a core runtime and tooling (v4.0) for planning, development and observability. Its main features include dedicated agent roles (analyst, PM, architect, scrum master, dev, QA), a two‚Äëphase process that first generates PRDs and architecture then produces hyper‚Äëdetailed story files for implementation, lifecycle hooks and IDE integrations, plus observability (SSE dashboards, logs, metrics). Technically it is a Node.js-based toolchain distributed via npx (aios-core CLI), relies on engineered prompts and human‚Äëin‚Äëthe‚Äëloop refinements, file-backed artifacts and hook adapters to integrate with multiple CLIs/IDEs, and provides install/upgrade flows that preserve project customizations.</p>
<p>The project benefits engineering teams, product managers and dev leads who need consistent, context-rich specification‚Äëto‚Äëcode handoffs and stronger automation of repetitive tasks, reducing context loss between planning and implementation. It also suits solo developers and non‚Äëtechnical domains (creative writing, business strategy, education) that can leverage domain‚Äëspecific agents to scale expertise quickly. Synkra is gaining attention because it combines agent orchestration, reproducible CLI‚Äëfirst workflows and IDE hook parity to improve developer productivity, governance and observability in AI‚Äëassisted software delivery.</p>
                    </div>
                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>

<script>
(() => {
    const readKey = "gtd:read_days:gh:v1";
    const dayStr = "2026-02-16";

    let stored = [];
    try {
        stored = JSON.parse(localStorage.getItem(readKey) || "[]");
        if (!Array.isArray(stored)) {
            stored = [];
        }
    } catch (_err) {
        stored = [];
    }

    if (!stored.includes(dayStr)) {
        stored.push(dayStr);
        stored.sort();
        localStorage.setItem(readKey, JSON.stringify(stored));
    }

    const collapseParam = new URLSearchParams(window.location.search).get("collapse_seen");
    const collapseSeen = collapseParam === "0" ? false : true;

    function setCollapsed(repoEl, collapsed) {
        repoEl.classList.toggle("collapsed", collapsed);
        const button = repoEl.querySelector(".repo-toggle");
        if (button) {
            button.textContent = collapsed ? "Show details" : "Hide details";
            button.setAttribute("aria-expanded", String(!collapsed));
        }
    }

    const repos = Array.from(document.querySelectorAll("section.repo[data-seen-before]"));

    repos.forEach((repoEl) => {
        const toggle = repoEl.querySelector(".repo-toggle");
        if (!toggle) {
            return;
        }

        toggle.addEventListener("click", () => {
            setCollapsed(repoEl, !repoEl.classList.contains("collapsed"));
        });
    });

    const collapseBtn = document.getElementById("collapse-seen-btn");
    const expandBtn = document.getElementById("expand-all-btn");

    if (collapseBtn) {
        collapseBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => {
                if (repoEl.dataset.seenBefore === "1") {
                    setCollapsed(repoEl, true);
                }
            });
        });
    }

    if (expandBtn) {
        expandBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => setCollapsed(repoEl, false));
        });
    }

    if (collapseSeen) {
        repos.forEach((repoEl) => {
            if (repoEl.dataset.seenBefore === "1") {
                setCollapsed(repoEl, true);
            }
        });
    }
})();
</script>

</body>
</html>
