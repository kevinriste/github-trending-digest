<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 11, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 11, 2026</h1>
        <nav>
            <a href="../">&larr; GitHub Calendar</a>
            <a href="../hn/">Hacker News</a>
        </nav>
    </header>
    <main>
        <div class="repo-controls">
            <button id="collapse-seen-btn" type="button">Collapse Repos Not New Today</button>
            <button id="expand-all-btn" type="button">Expand All</button>
        </div>
        <p class="seen-help">Repos marked "Not new today" appeared on one or more previous daily pages.</p>
        <article>
            <div class="repos">

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>1. <a href="https://github.com/google/langextract" target="_blank" rel="noopener noreferrer">google/langextract</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">A Python library for extracting structured information from unstructured text using LLMs with precise source grounding and interactive visualization.</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">29,077 stars</span>
                        | <span class="today">1,654 stars today</span>
                    </p>
                    <p class="history">First seen: February 09, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>LangExtract is a Python library that uses large language models to extract structured information from unstructured text while precisely grounding each extraction to its original source location. Key features include few‚Äëshot, prompt-driven extraction schemas, controlled generation for robust structured outputs (with support for models like Google Gemini and local LLMs via Ollama), optimized handling of long documents through chunking, parallel/multi‚Äëpass extraction to boost recall, and self‚Äëcontained interactive HTML visualizations alongside JSONL outputs for review. Technically, users provide a prompt and example extractions, the library divides texts into context windows, runs model calls (optionally in parallel or batch), aligns results to source offsets, and assembles validated, schema‚Äëconstrained outputs for downstream use.</p>
<p>This tooling is valuable for teams that need reliable, auditable structure from noisy text‚Äîclinical documentation (e.g., radiology/medication extraction), legal/contract review, research literature mining, content moderation, and annotation pipelines‚Äîbecause it combines scale with traceability and reviewer-friendly visualization. Organizations benefit from faster, consistent data extraction without model fine‚Äëtuning, and the project‚Äôs support for cloud and local providers, batch modes, and emphasis on explainability aligns with current demands for practical, controllable LLM applications, making it a timely and widely applicable solution.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>2. <a href="https://github.com/iOfficeAI/AionUi" target="_blank" rel="noopener noreferrer">iOfficeAI/AionUi</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Free, local, open-source 24/7 Cowork and OpenClaw for Gemini CLI, Claude Code, Codex, OpenCode, Qwen Code, Goose CLI, Auggie, and more | üåü Star if you like it!</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">14,657 stars</span>
                        | <span class="today">629 stars today</span>
                    </p>
                    <p class="history">First seen: February 09, 2026 | Consecutive daily streak: 3 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>AionUi is a free, open-source multi-agent desktop and WebUI that provides a unified graphical interface for command-line AI tools (with a built-in Gemini CLI out of the box) and auto-detects and integrates local CLIs such as Claude Code, Codex, Qwen Code, Goose AI, OpenClaw and others. Its main features include multi-session/local storage with independent conversation contexts, scheduled task automation, smart file management (batch rename, classification, merging), real-time previews for 9+ file formats, AI image generation/editing, and an extensible assistants/skills ecosystem (pptx, pdf, mermaid, etc.). Technically it runs as a cross-platform (macOS/Windows/Linux) WebUI and desktop app that orchestrates local and remote models via direct CLI integration or model gateways (NewAPI), supports local model runtimes like Ollama/LM Studio, and exposes remote access through WebUI and chat platforms (Telegram, Feishu/Lark) while keeping data stored locally.</p>
<p>AionUi is valuable for developers, data analysts, knowledge workers, and teams who rely on multiple command-line AI tools but need persistent sessions, file-centric automation, and an easier GUI-driven workflow; it streamlines office automation tasks like scheduled reports, batch file processing, and document generation. Its cross-platform, multi-model support and local-data focus make it a compelling, cost-free alternative to vendor-locked tools (e.g., Claude Cowork), and its extensible assistants and remote access options explain its traction among users looking to run 24/7 AI assistants and integrate AI into everyday workflows.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>3. <a href="https://github.com/KeygraphHQ/shannon" target="_blank" rel="noopener noreferrer">KeygraphHQ/shannon</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Fully autonomous AI hacker to find actual exploits in your web apps. Shannon has achieved a 96.15% success rate on the hint-free, source-aware XBOW Benchmark.</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">19,989 stars</span>
                        | <span class="today">3,619 stars today</span>
                    </p>
                    <p class="history">First seen: February 08, 2026 | Consecutive daily streak: 4 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Shannon is an autonomous AI pentester that analyzes a target application&#x27;s source code and then autonomously hunts for and executes real-world exploits using a built-in browser and command-line actions to produce reproducible proof-of-concept attacks. Its main features include detection and validation of critical OWASP vulnerabilities (injection, XSS, SSRF, broken auth/authorization), code-aware dynamic testing, parallelized workflows, and integrations with reconnaissance/testing tools such as Nmap, Subfinder, WhatWeb, and Schemathesis. Technically it runs as containerized workflows (Docker), leverages an LLM provider (Anthropic or Claude) to drive decision-making, and exposes monitoring via a workflow UI while emitting pentester-grade reports with copy-and-paste PoCs. This repository contains Shannon Lite (AGPL-3.0) for white-box source-available testing; a commercial Pro edition adds deeper LLM-powered data-flow analysis and enterprise integrations.</p>
<p>Shannon delivers clear value to security teams, DevOps, and independent researchers who need on-demand, reproducible penetration testing to close the gap between rapid shipping and infrequent manual pentests, because it verifies exploitable issues rather than just flagging potential vulnerabilities. It‚Äôs well suited for organizations that can provide source repositories and want continuous testing or CI/CD and compliance automation (e.g., SOC 2/HIPAA evidence collection), and for red teams that need scalable, repeatable attack validation. The project is gaining attention because it combines modern LLM orchestration with established security tooling to accelerate exploit discovery, reduce false positives through validated PoCs, and lower the operational cost of frequent security validation. Small teams can experiment with the AGPL Lite, while enterprises benefit from the Pro edition‚Äôs advanced analysis and support.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>4. <a href="https://github.com/github/gh-aw" target="_blank" rel="noopener noreferrer">github/gh-aw</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">GitHub Agentic Workflows</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">1,430 stars</span>
                        | <span class="today">496 stars today</span>
                    </p>
                    <p class="history">First seen: February 10, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>GitHub Agentic Workflows lets you describe agentic workflows in natural-language Markdown and execute them inside GitHub Actions, effectively combining Actions, autonomous agents, and built-in safety. Its main features include a Quick Start, workflow types and examples, Peli‚Äôs Agent Factory guided library, and extensive guardrails such as read-only-by-default run contexts, sanitized safe-outputs for writes, sandboxed execution, network isolation, SHA-pinned dependencies, tool allow-listing, compile-time validation, and human approval gates. Technically, the system parses Markdown workflows into actionable steps that invoke models and tools through controlled interfaces, with companion components like the AWF for egress control and the MCP Gateway for routed model calls to enforce policy and observability. The design emphasizes multilayered security and supply-chain protections so autonomous actions can be audited and constrained within repository CI/CD.</p>
<p>This project is valuable for developer teams, platform engineers, and security/DevOps groups who want to automate repository tasks‚Äîsuch as issue triage, code generation, dependency updates, and release orchestration‚Äîwhile maintaining rigorous safety and auditability. Organizations that need reproducible, policy-driven automation with human-in-the-loop approvals will benefit from the guardrails and enterprise-friendly controls. It‚Äôs trending because of the rapid adoption of LLM-driven agents to augment developer workflows and the demand for tightly integrated, secure automation within GitHub‚Äôs ecosystem. The combination of agentic convenience and explicit safety mechanisms makes it attractive for teams exploring trustworthy AI-assisted CI/CD.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>5. <a href="https://github.com/EveryInc/compound-engineering-plugin" target="_blank" rel="noopener noreferrer">EveryInc/compound-engineering-plugin</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Official Claude Code compound engineering plugin</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">8,235 stars</span>
                        | <span class="today">406 stars today</span>
                    </p>
                    <p class="history">First seen: February 11, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository provides a Claude Code plugin marketplace entry called the Compound Engineering Plugin that packages agent-driven engineering workflows and utilities to make each unit of work easier than the last. It ships a Bun/TypeScript CLI that converts Claude Code plugins into OpenCode, Codex, and Factory Droid formats and installs them, writing output to standard locations (~/.config/opencode, ~/.codex/, ~/.factory/) while mapping tool names and trimming namespaces as needed. The tool also supports syncing personal Claude Code configuration (symlinking skills from ~/.claude/ and copying MCP server settings) and exposes high-level workflow commands (/workflows:plan, /workflows:work, /workflows:review, /workflows:compound) to implement the Plan ‚Üí Work ‚Üí Review ‚Üí Compound cycle. Installation and conversion are driven by simple CLI commands (plugin marketplace install or bunx conversion), making cross-format exports and local development straightforward.</p>
<p>The project is useful for engineering teams and individuals adopting agent-centric workflows who need to standardize, migrate, or share skills across multiple agent ecosystems, or to codify review-driven processes that reduce future friction. By enabling portable exports, symlinked personal configs, and documented multi-agent workflows, it lowers the barrier to integrating Claude-based tooling into broader toolchains and accelerates onboarding. Teams focused on repeatable, high-quality execution and knowledge capture will benefit from the compound engineering philosophy that emphasizes planning and review to limit technical debt. Its emphasis on conversion and interoperability is timely given growing demand for cross-platform agent tooling and automation in software engineering.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>6. <a href="https://github.com/hsliuping/TradingAgents-CN" target="_blank" rel="noopener noreferrer">hsliuping/TradingAgents-CN</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Âü∫‰∫éÂ§öÊô∫ËÉΩ‰ΩìLLMÁöÑ‰∏≠ÊñáÈáëËûç‰∫§ÊòìÊ°ÜÊû∂ - TradingAgents‰∏≠ÊñáÂ¢ûÂº∫Áâà</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">16,773 stars</span>
                        | <span class="today">498 stars today</span>
                    </p>
                    <p class="history">First seen: February 10, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>TradingAgents-CN is a Chinese-enhanced fork of the TradingAgents multi-agent, LLM-driven financial research and simulated trading framework that focuses on A‚Äëshare, HK and US markets for learning and research. It centralizes multiple LLM providers (OpenAI, Google, domestic models) and implements multi-agent orchestration for tasks such as intelligent news analysis, multi-source data aggregation, automated model selection, stock screening, simulated trading and professional report export. Technically the project uses a FastAPI backend and Vue 3 frontend (noting these directories are treated as proprietary), MongoDB + Redis for storage/caching, RESTful APIs with WebSocket/SSE for realtime updates, Docker multi-architecture deployment, and integrations with Chinese data sources like Tushare/AkShare/BaoStock. The repository adopts a mixed license‚Äîmost code under Apache‚Äë2.0 while app/ and frontend/ are proprietary and require commercial authorization‚Äîand explicitly positions the platform for research/education rather than live trading.</p>
<p>This project is useful for researchers, educators, quant developers and hobbyists who want a packaged, Chinese-localized platform to prototype LLM-driven multi-agent workflows, backtest strategies, analyze news sentiment, and generate reproducible reports without building infrastructure from scratch. Its value comes from multi‚ÄëLLM vendor flexibility, containerized deployment, realtime UI/monitoring, and prebuilt integrations with Chinese market data, which lower the barrier for experimentation and teaching. The repo is trending because it combines cutting-edge LLM orchestration with practical deployment and Chinese market focus amid growing interest in AI for finance, though prospective users should respect the licensing limits and the disclaimer against using outputs as investment advice.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>7. <a href="https://github.com/gitbutlerapp/gitbutler" target="_blank" rel="noopener noreferrer">gitbutlerapp/gitbutler</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">The GitButler version control client, backed by Git, powered by Tauri/Rust/Svelte</p>
                    <p class="meta">
                        <span class="language">Rust</span> |
                        <span class="stars">19,092 stars</span>
                        | <span class="today">260 stars today</span>
                    </p>
                    <p class="history">First seen: February 10, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>GitButler is a Git-based version-control client that layers a friendlier, feature-rich UI and workflow on top of any existing Git repository. Its main features include stacked and parallel branches, drag-and-drop or CLI commit manipulation (uncommit, reword, amend, move, split, squash), an undo timeline that logs operations, first-class conflict handling, forge integrations (GitHub/GitLab) and built‚Äëin AI helpers for messages, branch names and PR content. The app is a Tauri desktop application with a Svelte + TypeScript frontend and a Rust backend; the same Rust engine powers the standalone &quot;but&quot; CLI so the desktop and CLI experiences share core logic. Operations are designed to restack commits automatically and make rebases and history edits straightforward without needing interactive rebase.</p>
<p>This project is valuable to individual developers, multi‚Äëdeveloper teams, maintainers and anyone who wants safer, more fluid history editing and parallel workstreams‚Äîespecially where automation or AI agents interact with repos. It reduces costly rebase and merge friction, speeds up PR workflows via forge integration, and provides recoverable operations through its undo timeline, making it attractive for code reviewers and release managers. GitButler is trending because it addresses long‚Äëstanding Git UX pain points with modern tooling (Tauri/Rust/Svelte), integrates AI and agent workflows, and offers a powerful drop‚Äëin replacement for typical Git client workflows.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>8. <a href="https://github.com/carlvellotti/claude-code-pm-course" target="_blank" rel="noopener noreferrer">carlvellotti/claude-code-pm-course</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Interactive course teaching Product Managers how to use Claude Code effectively</p>
                    <p class="meta">
                        <span class="language">MDX</span> |
                        <span class="stars">917 stars</span>
                        | <span class="today">24 stars today</span>
                    </p>
                    <p class="history">First seen: February 11, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository is an interactive, module-based course that teaches Product Managers how to use Claude Code effectively through guided, hands-on lessons and reference guides. Its main features include TaskFlow-based lessons (modules 0‚Äì2), visual workspace setup instructions, exercises for meeting notes, research analysis, PRD drafting, parallel agents, custom sub-agents, and a CLAUDE.md project memory for persistent context. Technically the content is delivered as repository files meant to be opened inside the Claude Code environment: you clone the repo, start Claude Code (claude), trigger lesson commands (e.g., /start-1-1), and follow in-environment guidance while avoiding local builds or npm installs until prompted. Lessons rely on Claude Code‚Äôs file navigation, agent orchestration, and on-repo memory rather than external build steps.</p>
<p>This course is useful for individual PMs, product teams, and onboarding or training programs that want practical, role-specific instruction on applying generative assistants to core PM workflows. Typical use cases include rapid PRD creation, structured data and research analysis, multi-perspective reviews via sub-agents, and automating repetitive document operations to boost throughput without sacrificing quality. Because it combines hands-on practice, repo-based context, and agent-driven workflows, it aligns with the current trend toward embedding conversational AI into day-to-day product work and upskilling teams to leverage these tools effectively.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>9. <a href="https://github.com/Shubhamsaboo/awesome-llm-apps" target="_blank" rel="noopener noreferrer">Shubhamsaboo/awesome-llm-apps</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Collection of awesome LLM apps with AI Agents and RAG using OpenAI, Anthropic, Gemini and opensource models.</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">93,724 stars</span>
                        | <span class="today">443 stars today</span>
                    </p>
                    <p class="history">First seen: February 10, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository is a curated collection of LLM-powered applications and templates showcasing Retrieval-Augmented Generation (RAG), AI agents, multi-agent teams, MCP, voice agents, and related tooling across OpenAI, Anthropic, Google Gemini, xAI and open-source models like Qwen and Llama. It organizes starter and advanced projects‚Äîagentic RAG, memory-enabled chat, voice/RAG agents, MCP integrations, multi-agent orchestration, and optimization/fine-tuning tutorials‚Äîeach with project-specific READMEs and run instructions. Technically the examples demonstrate embedding-based retrieval, agent orchestration patterns (function calling, tools, Pydantic structured outputs), hybrid local/cloud deployments, and workflows for fine-tuning and cost/context optimization, with reproducible setup via pip requirements and per-project code.</p>
<p>The collection provides practical blueprints for developers, researchers, and product teams to prototype, compare, and deploy LLM applications or learn agent design patterns and RAG pipelines. It‚Äôs useful for anyone building conversational apps, knowledge assistants, voice interfaces, autonomous agents, and domain-specific retrieval systems because it consolidates interoperable examples across major and open-source models. Its popularity stems from the rapid rise of agentic and multimodal LLM use cases, broad model support, and curated, well-documented reference implementations that accelerate adoption and experimentation.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>10. <a href="https://github.com/drawdb-io/drawdb" target="_blank" rel="noopener noreferrer">drawdb-io/drawdb</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Free, simple, and intuitive online database diagram editor and SQL generator.</p>
                    <p class="meta">
                        <span class="language">JavaScript</span> |
                        <span class="stars">36,417 stars</span>
                        | <span class="today">95 stars today</span>
                    </p>
                    <p class="history">First seen: February 11, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>DrawDB is a browser-based database entity-relationship (DBER) editor and SQL generator that lets users create, edit, and export database diagrams without signing up. Its main features include intuitive diagram building, SQL script export, editor customization, and optional file sharing; the README points to a fuller feature list in the project documentation. Technically it is a client-side web application with an npm-based development and build workflow and can be containerized with Docker for easy local deployment. If sharing is required, the project provides server-side setup and environment variables (see .env.sample) to enable collaboration functionality.</p>
<p>DrawDB is useful for developers, data architects, DBAs, educators, and students who need to prototype schemas, document databases, or teach relational modeling quickly. Because it generates SQL and supports export, it integrates into development workflows for rapid prototyping, code generation, and documentation. Its no-account approach, open-source availability, and Docker-ready deployment make it appealing and increasingly popular for teams and individuals seeking low-friction, portable tooling.</p>
                    </div>
                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>

<script>
(() => {
    const readKey = "gtd:read_days:gh:v1";
    const dayStr = "2026-02-11";

    let stored = [];
    try {
        stored = JSON.parse(localStorage.getItem(readKey) || "[]");
        if (!Array.isArray(stored)) {
            stored = [];
        }
    } catch (_err) {
        stored = [];
    }

    if (!stored.includes(dayStr)) {
        stored.push(dayStr);
        stored.sort();
        localStorage.setItem(readKey, JSON.stringify(stored));
    }

    const collapseParam = new URLSearchParams(window.location.search).get("collapse_seen");
    const collapseSeen = collapseParam === "0" ? false : true;

    function setCollapsed(repoEl, collapsed) {
        repoEl.classList.toggle("collapsed", collapsed);
        const button = repoEl.querySelector(".repo-toggle");
        if (button) {
            button.textContent = collapsed ? "Show details" : "Hide details";
            button.setAttribute("aria-expanded", String(!collapsed));
        }
    }

    const repos = Array.from(document.querySelectorAll("section.repo[data-seen-before]"));

    repos.forEach((repoEl) => {
        const toggle = repoEl.querySelector(".repo-toggle");
        if (!toggle) {
            return;
        }

        toggle.addEventListener("click", () => {
            setCollapsed(repoEl, !repoEl.classList.contains("collapsed"));
        });
    });

    const collapseBtn = document.getElementById("collapse-seen-btn");
    const expandBtn = document.getElementById("expand-all-btn");

    if (collapseBtn) {
        collapseBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => {
                if (repoEl.dataset.seenBefore === "1") {
                    setCollapsed(repoEl, true);
                }
            });
        });
    }

    if (expandBtn) {
        expandBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => setCollapsed(repoEl, false));
        });
    }

    if (collapseSeen) {
        repos.forEach((repoEl) => {
            if (repoEl.dataset.seenBefore === "1") {
                setCollapsed(repoEl, true);
            }
        });
    }
})();
</script>

</body>
</html>
