<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 11, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 11, 2026</h1>
        <nav>
            <a href="../">&larr; Back to Calendar</a>
        </nav>
    </header>
    <main>
        <article>
            <div class="repos">

            <section class="repo">
                <h3>1. <a href="https://github.com/google/langextract" target="_blank">google/langextract</a></h3>
                <p class="description">A Python library for extracting structured information from unstructured text using LLMs with precise source grounding and interactive visualization.</p>
                <p class="meta">
                    <span class="language">Python</span> |
                    <span class="stars">29,077 stars</span>
                    | <span class="today">1,654 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>LangExtract is a Python library that uses large language models to convert unstructured text into structured, schema-driven extractions while precisely grounding each extraction to its location in the source text. It relies on user-defined prompts and few-shot examples to enforce consistent output schemas, supports controlled generation for compatible models (e.g., Gemini), and handles long documents via chunking, parallel processing, and multiple extraction passes for higher recall. Results are saved as JSONL and can be rendered into a self-contained interactive HTML for visual review and traceability. The project also integrates with cloud providers (including Vertex AI batch) and local runtimes (via Ollama) to give flexible model choice and deployment options.</p>
<p>Organizations that need accurate, auditable information from messy text‚Äîsuch as healthcare (clinical notes and radiology reports), legal and compliance teams, research groups, and data engineering or ML annotation pipelines‚Äîbenefit most from LangExtract. Its precise source grounding and visualization make it well suited for human-in-the-loop validation, regulatory audits, and large-scale extraction at lower cost using batch/local options. The library is timely because demand for LLM-powered information extraction is growing, and teams increasingly require tools that balance model flexibility, reproducibility, and verifiable grounding of outputs.</p>

                </div>
            </section>

            <section class="repo">
                <h3>2. <a href="https://github.com/iOfficeAI/AionUi" target="_blank">iOfficeAI/AionUi</a></h3>
                <p class="description">Free, local, open-source 24/7 Cowork and OpenClaw for Gemini CLI, Claude Code, Codex, OpenCode, Qwen Code, Goose CLI, Auggie, and more | üåü Star if you like it!</p>
                <p class="meta">
                    <span class="language">TypeScript</span> |
                    <span class="stars">14,657 stars</span>
                    | <span class="today">629 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>AionUi is an open-source multi-agent &quot;Cowork&quot; interface that unifies local command-line AI tools (built-in Gemini CLI plus Claude Code, Codex, Qwen, Goose, OpenClaw, Augment Code, etc.) into a single desktop and WebUI experience. Its main features include automatic detection and integration of local CLIs, multi-session local conversation storage, scheduled tasks, smart file management (batch rename, auto-classify, merge), a 9+ format preview panel, image generation/editing, and an extensible assistants/skills ecosystem with CSS customization. Technically it detects installed CLI tools and model endpoints (cloud APIs and local runtimes like Ollama/LM Studio), wraps them in a WebUI and chat-platform bridges (Telegram, Feishu, LAN/remote access), and keeps data and sessions local to enable cross-platform deployment on macOS, Windows, and Linux.</p>
<p>This project is useful for developers, data analysts, knowledge workers, and small teams who rely on multiple CLI-based models but want persistent conversations, GUI-based file and document workflows, and remote 24/7 access without vendor lock‚Äëin. Typical use cases include scheduled report generation and automation, batch file organization and format conversions (PDF‚ÜíPPT, PPTX generation), code/document generation with live previews, and privacy-sensitive local model deployment. Its open-source, cross-platform, and multi-model/local deployment capabilities make it a cost‚Äëeffective, flexible alternative to proprietary cowork solutions, which explains its growing traction.</p>

                </div>
            </section>

            <section class="repo">
                <h3>3. <a href="https://github.com/KeygraphHQ/shannon" target="_blank">KeygraphHQ/shannon</a></h3>
                <p class="description">Fully autonomous AI hacker to find actual exploits in your web apps. Shannon has achieved a 96.15% success rate on the hint-free, source-aware XBOW Benchmark.</p>
                <p class="meta">
                    <span class="language">TypeScript</span> |
                    <span class="stars">19,989 stars</span>
                    | <span class="today">3,619 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Shannon is an autonomous AI pentester that analyzes a target application&#x27;s source code and then autonomously hunts for and executes real-world exploits using a built-in browser and command-line actions to produce reproducible proof-of-concept attacks. Its main features include detection and validation of critical OWASP vulnerabilities (injection, XSS, SSRF, broken auth/authorization), code-aware dynamic testing, parallelized workflows, and integrations with reconnaissance/testing tools such as Nmap, Subfinder, WhatWeb, and Schemathesis. Technically it runs as containerized workflows (Docker), leverages an LLM provider (Anthropic or Claude) to drive decision-making, and exposes monitoring via a workflow UI while emitting pentester-grade reports with copy-and-paste PoCs. This repository contains Shannon Lite (AGPL-3.0) for white-box source-available testing; a commercial Pro edition adds deeper LLM-powered data-flow analysis and enterprise integrations.</p>
<p>Shannon delivers clear value to security teams, DevOps, and independent researchers who need on-demand, reproducible penetration testing to close the gap between rapid shipping and infrequent manual pentests, because it verifies exploitable issues rather than just flagging potential vulnerabilities. It‚Äôs well suited for organizations that can provide source repositories and want continuous testing or CI/CD and compliance automation (e.g., SOC 2/HIPAA evidence collection), and for red teams that need scalable, repeatable attack validation. The project is gaining attention because it combines modern LLM orchestration with established security tooling to accelerate exploit discovery, reduce false positives through validated PoCs, and lower the operational cost of frequent security validation. Small teams can experiment with the AGPL Lite, while enterprises benefit from the Pro edition‚Äôs advanced analysis and support.</p>

                </div>
            </section>

            <section class="repo">
                <h3>4. <a href="https://github.com/github/gh-aw" target="_blank">github/gh-aw</a></h3>
                <p class="description">GitHub Agentic Workflows</p>
                <p class="meta">
                    <span class="language">Go</span> |
                    <span class="stars">1,430 stars</span>
                    | <span class="today">496 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>GitHub Agentic Workflows lets developers express &quot;agentic&quot; automation in natural-language Markdown and execute those agents within GitHub Actions, combining Actions + Agent + Safety. Its main features include a Quick Start, templates, Peli‚Äôs Agent Factory examples, and a security-first execution model that defaults to read-only runs and exposes write capabilities only through sanitized safe-outputs. Technically it enforces multiple layers of protection‚Äîsandboxed execution, input sanitization, network isolation, SHA‚Äëpinned dependencies, tool allow‚Äëlisting, compile‚Äëtime validation, and optional human approval gates‚Äîwhile integrating companion projects like Agent Workflow Firewall and MCP Gateway for network and model gateway controls.</p>
<p>This project is valuable to repository maintainers, DevOps and platform engineering teams, and security-focused organizations that want to safely automate routine tasks such as triage, code changes, dependency updates, testing, and release orchestration. By providing a structured, auditable way to run AI agents inside the familiar GitHub Actions environment with strong guardrails, it reduces manual effort and risk. Its traction reflects growing demand for practical AI-driven automation coupled with supply-chain security and governance, making it relevant for organizations adopting AI assistants at scale.</p>

                </div>
            </section>

            <section class="repo">
                <h3>5. <a href="https://github.com/EveryInc/compound-engineering-plugin" target="_blank">EveryInc/compound-engineering-plugin</a></h3>
                <p class="description">Official Claude Code compound engineering plugin</p>
                <p class="meta">
                    <span class="language">TypeScript</span> |
                    <span class="stars">8,235 stars</span>
                    | <span class="today">406 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>This repository implements the Compound Engineering Plugin and a Claude Code plugin marketplace that bundles agent-driven workflows (Plan, Work, Review, Compound) and CLI tools to install and manage the plugin. Technically it ships a Bun/TypeScript CLI to install plugins into Claude Code and to convert them into OpenCode and Codex formats, writing outputs to ~/.config/opencode and ~/.codex and creating symlinks for personal skills. Conversion produces OpenCode agents/skills/plugins and for Codex it emits prompts plus truncated skills (1024 character limit), with both provider targets marked experimental. The repo also includes workflow commands and sync utilities to pull MCP servers and skills from ~/.claude/settings.json so teams can reproduce agent-based planning, worktree execution, multi-agent review, and documentation compounding.</p>
<p>This project is valuable for engineering teams and organizations using Claude Code or seeking to interoperate with OpenCode/Codex by formalizing repeatable, agent-backed workflows and making knowledge capture explicit. It helps improve planning and review quality, supports automated multi-agent code review, and reduces friction when converting or syncing configurations across agent platforms. Given the shift toward AI-assisted developer tooling and standardization, platform engineers, maintainers, and AI-native teams will find it useful for compounding institutional knowledge and improving long-term productivity.</p>

                </div>
            </section>

            <section class="repo">
                <h3>6. <a href="https://github.com/hsliuping/TradingAgents-CN" target="_blank">hsliuping/TradingAgents-CN</a></h3>
                <p class="description">Âü∫‰∫éÂ§öÊô∫ËÉΩ‰ΩìLLMÁöÑ‰∏≠ÊñáÈáëËûç‰∫§ÊòìÊ°ÜÊû∂ - TradingAgents‰∏≠ÊñáÂ¢ûÂº∫Áâà</p>
                <p class="meta">
                    <span class="language">Python</span> |
                    <span class="stars">16,773 stars</span>
                    | <span class="today">498 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>TradingAgents-CN is a Chinese-enhanced fork of the TradingAgents multi-agent, LLM-driven financial research and simulated trading framework that focuses on A‚Äëshare, HK and US markets for learning and research. It centralizes multiple LLM providers (OpenAI, Google, domestic models) and implements multi-agent orchestration for tasks such as intelligent news analysis, multi-source data aggregation, automated model selection, stock screening, simulated trading and professional report export. Technically the project uses a FastAPI backend and Vue 3 frontend (noting these directories are treated as proprietary), MongoDB + Redis for storage/caching, RESTful APIs with WebSocket/SSE for realtime updates, Docker multi-architecture deployment, and integrations with Chinese data sources like Tushare/AkShare/BaoStock. The repository adopts a mixed license‚Äîmost code under Apache‚Äë2.0 while app/ and frontend/ are proprietary and require commercial authorization‚Äîand explicitly positions the platform for research/education rather than live trading.</p>
<p>This project is useful for researchers, educators, quant developers and hobbyists who want a packaged, Chinese-localized platform to prototype LLM-driven multi-agent workflows, backtest strategies, analyze news sentiment, and generate reproducible reports without building infrastructure from scratch. Its value comes from multi‚ÄëLLM vendor flexibility, containerized deployment, realtime UI/monitoring, and prebuilt integrations with Chinese market data, which lower the barrier for experimentation and teaching. The repo is trending because it combines cutting-edge LLM orchestration with practical deployment and Chinese market focus amid growing interest in AI for finance, though prospective users should respect the licensing limits and the disclaimer against using outputs as investment advice.</p>

                </div>
            </section>

            <section class="repo">
                <h3>7. <a href="https://github.com/gitbutlerapp/gitbutler" target="_blank">gitbutlerapp/gitbutler</a></h3>
                <p class="description">The GitButler version control client, backed by Git, powered by Tauri/Rust/Svelte</p>
                <p class="meta">
                    <span class="language">Rust</span> |
                    <span class="stars">19,092 stars</span>
                    | <span class="today">260 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>GitButler is a Git-based version-control client that layers a friendlier, feature-rich UI and workflow on top of any existing Git repository. Its main features include stacked and parallel branches, drag-and-drop or CLI commit manipulation (uncommit, reword, amend, move, split, squash), an undo timeline that logs operations, first-class conflict handling, forge integrations (GitHub/GitLab) and built‚Äëin AI helpers for messages, branch names and PR content. The app is a Tauri desktop application with a Svelte + TypeScript frontend and a Rust backend; the same Rust engine powers the standalone &quot;but&quot; CLI so the desktop and CLI experiences share core logic. Operations are designed to restack commits automatically and make rebases and history edits straightforward without needing interactive rebase.</p>
<p>This project is valuable to individual developers, multi‚Äëdeveloper teams, maintainers and anyone who wants safer, more fluid history editing and parallel workstreams‚Äîespecially where automation or AI agents interact with repos. It reduces costly rebase and merge friction, speeds up PR workflows via forge integration, and provides recoverable operations through its undo timeline, making it attractive for code reviewers and release managers. GitButler is trending because it addresses long‚Äëstanding Git UX pain points with modern tooling (Tauri/Rust/Svelte), integrates AI and agent workflows, and offers a powerful drop‚Äëin replacement for typical Git client workflows.</p>

                </div>
            </section>

            <section class="repo">
                <h3>8. <a href="https://github.com/carlvellotti/claude-code-pm-course" target="_blank">carlvellotti/claude-code-pm-course</a></h3>
                <p class="description">Interactive course teaching Product Managers how to use Claude Code effectively</p>
                <p class="meta">
                    <span class="language">MDX</span> |
                    <span class="stars">917 stars</span>
                    | <span class="today">24 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>This repository is an interactive, module-based course that teaches Product Managers how to use Claude Code effectively through guided, hands-on lessons and reference guides. Its main features include TaskFlow-based lessons (modules 0‚Äì2), visual workspace setup instructions, exercises for meeting notes, research analysis, PRD drafting, parallel agents, custom sub-agents, and a CLAUDE.md project memory for persistent context. Technically the content is delivered as repository files meant to be opened inside the Claude Code environment: you clone the repo, start Claude Code (claude), trigger lesson commands (e.g., /start-1-1), and follow in-environment guidance while avoiding local builds or npm installs until prompted. Lessons rely on Claude Code‚Äôs file navigation, agent orchestration, and on-repo memory rather than external build steps.</p>
<p>This course is useful for individual PMs, product teams, and onboarding or training programs that want practical, role-specific instruction on applying generative assistants to core PM workflows. Typical use cases include rapid PRD creation, structured data and research analysis, multi-perspective reviews via sub-agents, and automating repetitive document operations to boost throughput without sacrificing quality. Because it combines hands-on practice, repo-based context, and agent-driven workflows, it aligns with the current trend toward embedding conversational AI into day-to-day product work and upskilling teams to leverage these tools effectively.</p>

                </div>
            </section>

            <section class="repo">
                <h3>9. <a href="https://github.com/Shubhamsaboo/awesome-llm-apps" target="_blank">Shubhamsaboo/awesome-llm-apps</a></h3>
                <p class="description">Collection of awesome LLM apps with AI Agents and RAG using OpenAI, Anthropic, Gemini and opensource models.</p>
                <p class="meta">
                    <span class="language">Python</span> |
                    <span class="stars">93,724 stars</span>
                    | <span class="today">443 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>This repository is a curated collection of real-world LLM applications and example projects demonstrating Retrieval-Augmented Generation (RAG), AI Agents, multi-agent teams, MCP, voice agents, memory, and fine-tuning workflows. It aggregates starter-to-advanced app templates and tutorials that integrate commercial models (OpenAI, Anthropic, Gemini, xAI) and open-source models (Qwen, Llama), showing both local and cloud deployments, embeddings and retrieval pipelines, structured outputs, tool/function calling, and agent orchestration patterns. Each entry includes project-specific READMEs and reproducible setup instructions so developers can run, adapt, or benchmark the apps and patterns end-to-end.</p>
<p>The collection is valuable for engineers, researchers, product teams, educators, and startups looking to prototype or productionize LLM-driven features‚Äîsuch as domain-specific chatbots, voice assistants, autonomous research agents, and RAG-backed search‚Äîusing best-practice patterns. It accelerates adoption by providing ready examples for memory, multi-agent coordination, cost/response optimizations, and fine-tuning, and is timely because the rapid evolution of multimodal LLMs, agent paradigms, and open-source model improvements has created strong demand for practical, interoperable reference implementations.</p>

                </div>
            </section>

            <section class="repo">
                <h3>10. <a href="https://github.com/drawdb-io/drawdb" target="_blank">drawdb-io/drawdb</a></h3>
                <p class="description">Free, simple, and intuitive online database diagram editor and SQL generator.</p>
                <p class="meta">
                    <span class="language">JavaScript</span> |
                    <span class="stars">36,417 stars</span>
                    | <span class="today">95 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>DrawDB is a browser-based database entity-relationship (DBER) editor and SQL generator that lets users create, edit, and export database diagrams without signing up. Its main features include intuitive diagram building, SQL script export, editor customization, and optional file sharing; the README points to a fuller feature list in the project documentation. Technically it is a client-side web application with an npm-based development and build workflow and can be containerized with Docker for easy local deployment. If sharing is required, the project provides server-side setup and environment variables (see .env.sample) to enable collaboration functionality.</p>
<p>DrawDB is useful for developers, data architects, DBAs, educators, and students who need to prototype schemas, document databases, or teach relational modeling quickly. Because it generates SQL and supports export, it integrates into development workflows for rapid prototyping, code generation, and documentation. Its no-account approach, open-source availability, and Docker-ready deployment make it appealing and increasingly popular for teams and individuals seeking low-friction, portable tooling.</p>

                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>
</body>
</html>
