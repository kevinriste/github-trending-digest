<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 08, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 08, 2026</h1>
        <nav>
            <a href="../">&larr; Back to Calendar</a>
        </nav>
    </header>
    <main>
        <article>
            <div class="repos">

            <section class="repo">
                <h3>1. <a href="https://github.com/KeygraphHQ/shannon" target="_blank">KeygraphHQ/shannon</a></h3>
                <p class="description">Fully autonomous AI hacker to find actual exploits in your web apps. Shannon has achieved a 96.15% success rate on the hint-free, source-aware XBOW Benchmark.</p>
                <p class="meta">
                    <span class="language">TypeScript</span> |
                    <span class="stars">10,494 stars</span>
                    | <span class="today">3,139 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Shannon is a fully autonomous AI pentester that hunts for and proves real exploits in web applications, reporting reproducible proof-of-concepts and claiming a 96.15% success rate on a hint-free, source-aware XBOW benchmark. It identifies and validates critical issues such as injection, XSS, SSRF, and broken authentication, operates a built-in browser to execute live exploits (including complex flows like 2FA/TOTP and OAuth), and produces pentester-grade reports focused on confirmed, actionable findings. Technically, Shannon is white-box onlyâ€”it analyzes source code to guide attacks, leverages integrated reconnaissance and testing tools (Nmap, Subfinder, WhatWeb, Schemathesis), parallelizes heavy phases for speed, and runs via Docker with LLM-based orchestration (Anthropic/Claude supported).</p>
<p>Shannon is valuable to security teams, independent researchers, and development organizations that need on-demand, repeatable penetration testing integrated into fast release cycles or CI/CD pipelines, especially where annual manual pentests leave long exposure windows. By delivering verified exploits rather than alerts, it reduces false positives and accelerates remediation, making it well suited for internal testing of monorepos or consolidated codebases. Its AI-driven automation and integration into a broader security and compliance platform explain why similar LLM-powered offensive tooling is gaining traction, while the projectâ€™s dual licensing (AGPL Lite and a commercial Pro edition) provides options for open use or enterprise features.</p>

                </div>
            </section>

            <section class="repo">
                <h3>2. <a href="https://github.com/openai/skills" target="_blank">openai/skills</a></h3>
                <p class="description">Skills Catalog for Codex</p>
                <p class="meta">
                    <span class="language">Python</span> |
                    <span class="stars">6,253 stars</span>
                    | <span class="today">592 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Agent Skills is a cataloged collection of reusable folders containing instructions, scripts, and resources that AI agents (Codex) can discover and use to perform specific tasks. The repository organizes skills into locations like .system (auto-installed), .curated, and .experimental, and provides a $skill-installer utility to install skills by name, folder, or GitHub URL; after installation Codex must be restarted to pick up additions. Each skill is self-contained and includes its own LICENSE.txt so teams can manage distribution and reuse. Overall, the project packages repeatable capabilities into modular artifacts that Codex can load and execute.</p>
<p>This approach is valuable because it enables developers, ML engineers, platform teams, and product owners to share, reuse, and compose agent behaviors quickly, reducing duplication and accelerating automation. Common use cases include automating routine workflows, embedding organization-specific knowledge and scripts into agents, and building higher-level planning or data-processing pipelines from modular skills. The project aligns with the trend toward agent-driven automation and standardization, making it easier for organizations to govern, distribute, and iterate on agent capabilities.</p>

                </div>
            </section>

            <section class="repo">
                <h3>3. <a href="https://github.com/microsoft/litebox" target="_blank">microsoft/litebox</a></h3>
                <p class="description">A security-focused library OS supporting kernel- and user-mode execution</p>
                <p class="meta">
                    <span class="language">Rust</span> |
                    <span class="stars">1,193 stars</span>
                    | <span class="today">584 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>LiteBox is a security-focused library OS that minimizes the host-facing interface to drastically reduce attack surface while enabling sandboxed execution in both kernel and user-mode contexts. It provides a Rust-y, nix/rustix-inspired &quot;North&quot; API for applications and composes with pluggable &quot;South&quot; Platform interfaces that implement the underlying host semantics, allowing flexible Northâ€“South pairings. Technically this design decouples application-facing POSIX-like operations from platform-specific implementations, enabling shims that let the same guest binaries run across diverse environments such as Linux-on-Windows, SEV SNP enclaves, OP-TEE, and LVBS. The project is actively evolving, documented under MIT license, and emphasizes easy interop between different shims and platforms.</p>
<p>LiteBox is valuable to security engineers, OS researchers, cloud and enclave developers, and anyone needing strong sandboxing or cross-platform compatibility for unmodified binaries. It enables scenarios like running Linux programs on Windows, hardening Linux services with reduced kernel exposure, and experimenting with confidential computing technologies (SEV SNP, TEEs) without rewriting application code. Because it reduces host-OS dependencies while supporting pluggable platforms, itâ€™s useful for prototyping secure execution models, portability layers, and isolation solutionsâ€”trends driven by rising security threats and increasing demand for confidential computing.</p>

                </div>
            </section>

            <section class="repo">
                <h3>4. <a href="https://github.com/p-e-w/heretic" target="_blank">p-e-w/heretic</a></h3>
                <p class="description">Fully automatic censorship removal for language models</p>
                <p class="meta">
                    <span class="language">Python</span> |
                    <span class="stars">4,787 stars</span>
                    | <span class="today">69 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Heretic is a command-line tool that automatically removes safety-aligned censorship from transformer-based language models using an implementation of directional ablation (&quot;abliteration&quot;) combined with a TPE-based hyperparameter optimizer (Optuna). It searches for abliteration parameters that co-minimize refusal rates on &quot;harmful&quot; prompts and KL divergence from the original model on &quot;harmless&quot; prompts, producing decensored models that aim to retain as much original capability as possible. The workflow is fully automated (including hardware-aware batching), supports many dense and some MoE architectures, and exposes research utilities such as residual-vector plotting, PaCMAP projections, and geometric diagnostics for interpretability work. Installation and use are via a simple pip package and CLI (heretic), with optional research extras for deeper analysis.</p>
<p>Heretic is valuable for researchers studying model internals and safety trade-offs, ML practitioners who need fine-grained control over model refusal behavior, and hobbyists who want to experiment with uncensoring models without manual intervention; it can produce lower-KL decensorings that preserve capability while reducing refusals. Its automation, quantitative objective (refusal vs. KL), and built-in evaluation/visualization tools help standardize and accelerate experiments in alignment and interpretability, which contributes to its visibility and adoption. At the same time, its capability to remove safety filters makes it controversial and primarily relevant to responsible research contexts where ethical and legal implications are considered.</p>

                </div>
            </section>

            <section class="repo">
                <h3>5. <a href="https://github.com/obra/superpowers" target="_blank">obra/superpowers</a></h3>
                <p class="description">An agentic skills framework &amp; software development methodology that works.</p>
                <p class="meta">
                    <span class="language">Shell</span> |
                    <span class="stars">47,132 stars</span>
                    | <span class="today">686 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Superpowers is an agentic skills framework and opinionated software development workflow that equips coding agents with a library of composable &quot;skills&quot; and starter instructions to plan, implement, test, and review software autonomously. Its main features include brainstorming and design refinement, breaking work into small, verifiable tasks, using git worktrees for isolated branches, a strict RED-GREEN-REFACTOR TDD cycle, subagent-driven development with two-stage reviews, and automated checkpoints for finishing branches. Technically it ships as a skills repository and plugin (with specific install paths for Claude Code, Codex, and OpenCode), where each skill is stored in the repo and agents spawn subagents and isolated worktrees per task to follow explicit file-level plans and verification steps. Skills update via the plugin marketplace or manual install and the workflow enforces test-first, evidence-based progression through the plan.</p>
<p>This project is useful for developers and organizations adopting LLM-based coding assistants who need reproducible, auditable, and test-first development cycles while delegating routine engineering tasks to agents. By enforcing small task granularity, mandatory tests, and multi-stage reviews it reduces context drift and increases the reliability of agent-produced code, improving productivity and lowering the risk of regressions. Teams building internal agent tooling, open-source maintainers coordinating autonomous contributions, and individual developers experimenting with agentic workflows will benefit most. Its open-source plugin model, emphasis on TDD and systematic process, and compatibility with popular agent platforms make it especially relevant as agentic automation trends grow.</p>

                </div>
            </section>

            <section class="repo">
                <h3>6. <a href="https://github.com/OpenBMB/MiniCPM-o" target="_blank">OpenBMB/MiniCPM-o</a></h3>
                <p class="description">A Gemini 2.5 Flash Level MLLM for Vision, Speech, and Full-Duplex Multimodal Live Streaming on Your Phone</p>
                <p class="meta">
                    <span class="language">Python</span> |
                    <span class="stars">23,201 stars</span>
                    | <span class="today">44 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>MiniCPM-o is an open-source series of on-device multimodal large language models that take images, video, text, and audio as inputs and produce high-quality text and speech outputs end-to-end. Its flagship MiniCPM-o 4.5 (â‰ˆ9B params) emphasizes fullâ€‘duplex multimodal live streamingâ€”simultaneous non-blocking input and output streamsâ€”while MiniCPM-V 4.0 (â‰ˆ4B) targets extremely efficient phone deployment with strong image understanding and OCR. Technically it uses transformer-based MLLM architectures with quantized GGUF formats and is integrated with inference toolchains and demos (llama.cpp/vLLM/Ollama forks, WebRTC demo, Docker), plus alignment/fine-tuning tools like RLAIF for practical deployment and voice cloning/bilingual speech features.</p>
<p>This project is valuable for developers and researchers building realâ€‘time multimodal agents, onâ€‘device assistants, AR/VR companions, accessibility tools, and privacyâ€‘sensitive applications that require low-latency local inference. Mobile app teams, edge deployment engineers, and hobbyists benefit from the small/efficient model variants and broad ecosystem support (quantization, llama.cpp, Docker/WebRTC demos) that make experimentation and production easier. Its rapid open-source releases, competitive performance versus commercial models (Gemini/GPT variants), and ready-to-run demos and integration guides explain why it is gaining traction in the community.</p>

                </div>
            </section>

            <section class="repo">
                <h3>7. <a href="https://github.com/aquasecurity/trivy" target="_blank">aquasecurity/trivy</a></h3>
                <p class="description">Find vulnerabilities, misconfigurations, secrets, SBOM in containers, Kubernetes, code repositories, clouds and more</p>
                <p class="meta">
                    <span class="language">Go</span> |
                    <span class="stars">31,709 stars</span>
                    | <span class="today">168 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Trivy is a comprehensive security scanner that detects vulnerabilities, misconfigurations, secrets and produces SBOMs across container images, filesystems, Git repositories, VM images and Kubernetes clusters. It bundles multiple scanners for OS packages and language dependencies, known CVEs, IaC misconfigurations, secret detection and license checks, and supports most popular languages, OSes and platforms. Technically, Trivy is a Go-based CLI and library that inspects artifacts directly (image layers, files, git trees, k8s API), consults vulnerability and SBOM data sources, and emits reports in multiple formats. It runs as a standalone binary or container, integrates with CI/CD and ecosystem tools (GitHub Actions, k8s operator, VS Code), and provides canary builds for rapid iteration.</p>
<p>Trivy is valuable to developers, DevSecOps and security teams who need fast, automated detection of security issues across the software supply chain. Typical use cases include shift-left scanning in CI pipelines, pre-deployment Kubernetes audits, image/VM hardening, repository secret detection and SBOM generation for compliance. Its broad coverage, ease of installation and integration, and active open-source maintenance by Aqua make it attractive for organizations prioritizing supply-chain security. The project is trending because it delivers pragmatic, multi-target scanning and policy-driven automation that fits modern cloud-native workflows.</p>

                </div>
            </section>

            <section class="repo">
                <h3>8. <a href="https://github.com/wavetermdev/waveterm" target="_blank">wavetermdev/waveterm</a></h3>
                <p class="description">An open-source, cross-platform terminal for seamless workflows</p>
                <p class="meta">
                    <span class="language">Go</span> |
                    <span class="stars">17,170 stars</span>
                    | <span class="today">25 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Wave is an open-source, cross-platform terminal that blends a traditional CLI with graphical capabilities like file previews, embedded web browsing, a built-in editor, and an AI assistant. It exposes a draggable multi-block workspace containing terminals, editors, preview widgets and AI chat panels, plus features such as command blocks, one-click SSH/remote connections, secure native secret storage, and connected file management (including Wave filesystem and S3). Technically it runs on macOS, Linux and Windows, uses a WSH helper and the wsh CLI to manage workspaces and share data across sessions, and integrates multiple AI providers (OpenAI, Claude, Azure, Perplexity, Ollama) so Wave AI can read terminal context, suggest edits, and perform file operations with user approval. Customization, theming, and scripting via wsh let users automate workflows and persist or share workspace state.</p>
<p>Wave is valuable to developers, sysadmins, DevOps engineers, and remote teams who frequently switch between terminals and graphical tools, because it reduces context switching by consolidating previews, documentation, remote file editing, and AI assistance into a single environment. It speeds debugging, file manipulation, and monitoring workflows while simplifying remote access and synchronized file transfers across hosts. The integrated AI assistant and extensible CLI tooling make Wave appealing for teams seeking assisted coding, reproducible workflows, and automation, and its open-source, cross-platform design with multiple AI provider options helps explain its growing adoption.</p>

                </div>
            </section>

            <section class="repo">
                <h3>9. <a href="https://github.com/viarotel-org/escrcpy" target="_blank">viarotel-org/escrcpy</a></h3>
                <p class="description">ðŸ“± Display and control your Android device graphically with scrcpy.</p>
                <p class="meta">
                    <span class="language">JavaScript</span> |
                    <span class="stars">7,884 stars</span>
                    | <span class="today">27 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>Escrcpy is a graphical tool for displaying and controlling Android devices that extends the popular scrcpy screen-mirroring core with a polished Electron/Vue GUI and added automation. Its main features include natural-language intelligent control via AutoGLM, automated workflows with parallel multi-device execution, window orchestration for managing several devices, and wireless connectivity including Gnirehtet reverse tethering. Technically it combines scrcpy for low-latency mirroring, adbkit for ADB interactions, autoglm.js for language-driven commands, and Electron/Vue for the cross-platform desktop interface, with packaged releases and a Homebrew tap for macOS.</p>
<p>This project is valuable for mobile developers, QA engineers, support teams, and anyone who needs centralized control or automated testing across multiple Android devices because it simplifies remote interaction, scripting, and parallel device orchestration. The addition of natural-language control and reverse-tethering support makes it useful for automation-driven workflows, demos, and networks where devices lack direct internet access. Its momentum comes from building on well-known open-source components (scrcpy, adbkit, gnirehtet) while adding convenience features and a GUI that address common multi-device and automation pain points.</p>

                </div>
            </section>

            <section class="repo">
                <h3>10. <a href="https://github.com/ComposioHQ/awesome-claude-skills" target="_blank">ComposioHQ/awesome-claude-skills</a></h3>
                <p class="description">A curated list of awesome Claude Skills, resources, and tools for customizing Claude AI workflows</p>
                <p class="meta">
                    <span class="language">Python</span> |
                    <span class="stars">32,160 stars</span>
                    | <span class="today">443 stars today</span>
                </p>
                <div class="ai-summary">
                    <h4>Analysis</h4>
                    <p>This repository is a curated collection of Claude Skillsâ€”reusable, customizable workflows and tools for Claude.ai, Claude Code, and the Claude APIâ€”grouped by categories like document processing, development &amp; code tools, data &amp; analysis, business &amp; marketing, and more. It bundles ready-made skills (e.g., PDF/DOCX/XLSX handlers, Playwright browser automation, changelog generation, CSV summarizers, Postgres query tooling) and integration helpers such as the Composio connect-apps plugin that links Claude to 500+ or 1000+ external apps. Technically, skills are implemented as model-invoked workflows and plugins that teach Claude task-specific behaviors and, when installed (for example via claude --plugin-dir and /connect-apps:setup), let the assistant perform real actions by handling auth and API calls through Composio. The repo also includes guidance for creating new skills, developer-focused tooling, and community-contributed recipes to extend Claudeâ€™s capabilities.</p>
<p>The project is valuable to developers, product teams, data analysts, content creators, and ops/security engineers who want to standardize and automate work with an LLM that can take actions beyond text generationâ€”sending emails, creating issues, posting to Slack, running tests, extracting data, and more. It accelerates workflows by providing off-the-shelf, tested patterns and connectors that bridge Claude to databases, CI, cloud services, and SaaS apps, reducing engineering overhead to build integrations from scratch. Its popularity is driven by growing demand for agentic, action-capable AI, broad app connectivity via Composio, and an active community contributing domain-specific skills that make deployment and iteration fast and practical.</p>

                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>
</body>
</html>
