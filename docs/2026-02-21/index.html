<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 21, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 21, 2026</h1>
        <nav>
            <a href="../">&larr; GitHub Calendar</a>
            <a href="../hn/2026-02-21/">Hacker News</a>
        </nav>
    </header>
    <main>
        <div class="repo-controls">
            <button id="collapse-seen-btn" type="button">Collapse Repos Not New Today</button>
            <button id="expand-all-btn" type="button">Expand All</button>
        </div>
        <p class="seen-help">Repos marked "Not new today" appeared on one or more previous daily pages.</p>
        <article>
            <div class="repos">

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>1. <a href="https://github.com/vxcontrol/pentagi" target="_blank" rel="noopener noreferrer">vxcontrol/pentagi</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">âœ¨ Fully autonomous AI Agents system capable of performing complex penetration testing tasks</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">4,235</span>
                        | <span class="today">875 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>PentAGI is an autonomous penetration-testing platform that orchestrates LLM-driven agents to plan, research, and execute security assessments within sandboxed Docker environments. It integrates a suite of 20+ professional tools (nmap, metasploit, sqlmap), a long-term memory stored in PostgreSQL with pgvector, a Graphiti/Neo4j knowledge graph for semantic context, web-scraping and external search connectors, and automated container selection to run tasks safely. Technically it is a microservices stack (React/TypeScript UI, Go GraphQL API, task queue and asynchronous agents) with observability (Grafana/Langfuse/Prometheus-style components), extensive LLM provider support, and deployability via Docker Compose.</p>
<p>Security engineers, red teams, researchers, and organizations needing scalable, repeatable penetration testing will benefit from PentAGI because it automates routine discovery and exploitation workflows, preserves and indexes findings for reuse, and centralizes reporting and monitoring. It is trending due to advances in multi-agent LLM orchestration, growing demand for self-hosted and auditable AI-driven tools, and the practical combination of vector memory, knowledge graphs, and observability that make autonomous security workflows more reliable and useful in production environments.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>2. <a href="https://github.com/blackboardsh/electrobun" target="_blank" rel="noopener noreferrer">blackboardsh/electrobun</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Build ultra fast, tiny, and cross-platform desktop apps with Typescript.</p>
                    <p class="meta">
                        <span class="language">C++</span> |
                        <span class="stars">6,145</span>
                        | <span class="today">419 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Electrobun is a solution-in-a-box for building ultra-fast, tiny, cross-platform desktop applications using TypeScript. Technically it runs the main process and bundles webview TypeScript with bun, exposes native functionality via Zig bindings, and enforces isolation between main and webview processes with fast, typed RPC. The toolchain focuses on very small self-extracting app bundles (around 12 MB when using the system webview) and supports minimal binary updates (as small as ~14 KB using bsdiff), while providing templates and CLI workflows to get running quickly.</p>
<p>This project is aimed at developers who want to write desktop apps in TypeScript without managing multiple runtimes or complex native toolchains â€” particularly those prioritizing performance, tiny distributions, and easy incremental updates. Itâ€™s gaining traction because it combines bunâ€™s high-performance JS runtime, a compact packaging/update story, cross-platform support (macOS, Windows, Ubuntu), and a strong developer experience with templates and integrated build/dev commands.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>3. <a href="https://github.com/HailToDodongo/pyrite64" target="_blank" rel="noopener noreferrer">HailToDodongo/pyrite64</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">N64 Game-Engine and Editor using libdragon &amp; tiny3d</p>
                    <p class="meta">
                        <span class="language">C++</span> |
                        <span class="stars">2,171</span>
                        | <span class="today">425 stars today</span>
                    </p>
                    <p class="history">First seen: February 19, 2026 | Consecutive daily streak: 3 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Pyrite64 is an open-source Nintendo 64 game engine and editor that targets homebrew development by leveraging libdragon for hardware abstraction and tiny3d for low-level GPU rendering. The project bundles an in-console runtime with an editor and asset pipeline so creators can design scenes, manage resources, and build ROMs or run in emulators. Key features include a real-time 3D renderer, input and file I/O integration, and build scripts/tooling to cross-compile and package content for N64 hardware. Technically it ties together the N64 toolchain, libdragon APIs, and tiny3d primitives to deliver an integrated development workflow for the console.</p>
<p>This project benefits retro developers, hobbyists, educators, and anyone interested in creating or studying N64-era games because it lowers the barrier to producing and iterating on content for the console. It is trending in the homebrew and preservation communities due to renewed interest in retro platforms, improving cross-compile toolchains, and the appeal of a single repository that combines editor, engine, and deployment tools for rapid prototyping on real hardware or emulators.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>4. <a href="https://github.com/obra/superpowers" target="_blank" rel="noopener noreferrer">obra/superpowers</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">An agentic skills framework &amp; software development methodology that works.</p>
                    <p class="meta">
                        <span class="language">Shell</span> |
                        <span class="stars">56,382</span>
                        | <span class="today">980 stars today</span>
                    </p>
                    <p class="history">First seen: February 04, 2026 | Consecutive daily streak: 5 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Superpowers is a complete software development workflow for coding agents built around composable &quot;skills&quot; and starter instructions that make agents follow a consistent process. Key features include a modular skills library (TDD, systematic debugging, brainstorming, plan-writing, subagent-driven development, code review, and git worktree management), an enforced workflow that moves from spec elicitation to plan to task-level subagents, and a two-stage review system (spec compliance then code quality). Technically it ships as a plugin (Claude Code marketplace) with manual install paths for Codex and OpenCode, stores skills directly in the repository, and has agents fetch and execute skills, spawn subagents per task, and run automated verification and test-driven cycles. The repo also contains contribution guidance and update mechanics so skills can be extended and updated easily.</p>
<p>This project benefits developers, teams, and tool builders who want repeatable, evidence-driven AI-assisted engineeringâ€”especially those who need automated testing, clear task plans, and controlled parallel work via subagents. Itâ€™s gaining traction because it addresses practical pain points in agentic coding (avoiding ad-hoc behavior, enforcing REDâ€‘GREENâ€‘REFACTOR, and integrating with git workflows) while offering an easy integration path for Claude Code and extensibility via an open-source MIT-licensed skill library.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>5. <a href="https://github.com/aquasecurity/trivy" target="_blank" rel="noopener noreferrer">aquasecurity/trivy</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Find vulnerabilities, misconfigurations, secrets, SBOM in containers, Kubernetes, code repositories, clouds and more</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">32,128</span>
                        | <span class="today">31 stars today</span>
                    </p>
                    <p class="history">First seen: February 06, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Trivy is a comprehensive security scanner that detects vulnerabilities, misconfigurations, secrets and produces SBOMs across container images, filesystems, Git repositories, VM images and Kubernetes clusters. It bundles multiple scanners for OS packages and language dependencies, known CVEs, IaC misconfigurations, secret detection and license checks, and supports most popular languages, OSes and platforms. Technically, Trivy is a Go-based CLI and library that inspects artifacts directly (image layers, files, git trees, k8s API), consults vulnerability and SBOM data sources, and emits reports in multiple formats. It runs as a standalone binary or container, integrates with CI/CD and ecosystem tools (GitHub Actions, k8s operator, VS Code), and provides canary builds for rapid iteration.</p>
<p>Trivy is valuable to developers, DevSecOps and security teams who need fast, automated detection of security issues across the software supply chain. Typical use cases include shift-left scanning in CI pipelines, pre-deployment Kubernetes audits, image/VM hardening, repository secret detection and SBOM generation for compliance. Its broad coverage, ease of installation and integration, and active open-source maintenance by Aqua make it attractive for organizations prioritizing supply-chain security. The project is trending because it delivers pragmatic, multi-target scanning and policy-driven automation that fits modern cloud-native workflows.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>6. <a href="https://github.com/PostHog/posthog" target="_blank" rel="noopener noreferrer">PostHog/posthog</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">ðŸ¦” PostHog is an all-in-one developer platform for building successful products. We offer product analytics, web analytics, session replay, error tracking, feature flags, experimentation, surveys, data warehouse, a CDP, and an AI product assistant to help debug your code, ship features faster, and keep all your usage and customer data in one stack.</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">31,614</span>
                        | <span class="today">46 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>PostHog is an all-in-one open-source platform for building successful products, combining product and web analytics, session replay, error tracking, feature flags, experiments, surveys, data pipelines, data warehouse integrations, LLM analytics, workflows, and an AI product assistant. It captures data via autocapture, SDKs, or a public API and enables analysis with built-in visualizations or SQL, while allowing real-time or batch exports to warehouses and 25+ tools. The repository is organized as a monorepo with cloud and self-hosting options (recommended PostHog Cloud or a one-line Docker hobby deploy) and provides SDKs for many frontend, mobile, and backend frameworks. The project is MIT-licensed (with a separate ee directory) and offers generous free monthly tiers to get started quickly.</p>
<p>Product managers, developers, growth and analytics teams, and startups benefit from PostHog because it consolidates telemetry, experimentation, feature delivery, and error monitoring into a single stack, reducing tool sprawl and keeping control over customer data. Itâ€™s trending due to its open-source model, flexible deployment (self-host or cloud), broad SDK ecosystem, and emphasis on privacy and developer ergonomics, together with practical features like session replay and built-in experimentation. Transparent pricing, free quotas, and an active contributor community further accelerate adoption for teams wanting faster product iteration and more ownership of their analytics.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>7. <a href="https://github.com/eslint/eslint" target="_blank" rel="noopener noreferrer">eslint/eslint</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Find and fix problems in your JavaScript code.</p>
                    <p class="meta">
                        <span class="language">JavaScript</span> |
                        <span class="stars">27,073</span>
                        | <span class="today">30 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>ESLint is a static analysis tool that identifies and reports on problematic patterns in JavaScript/ECMAScript code and can optionally fix some issues automatically. It parses source files with Espree into an AST and evaluates pluggable rules (each rule is a plugin) to detect patterns and enforce policies. The tool is highly configurable via eslint.config.js (with rule severity levels like off/warn/error), supports JSX and alternative parsers (e.g., @babel/eslint-parser) for language extensions, and is run via npx or installed with npm/pnpm under supported Node.js versions.</p>
<p>Frontend and backend JavaScript developers, teams, and CI pipelines benefit from ESLint because it enforces consistent styles, catches bugs early, and integrates with editors and build systems. Its extensible plugin ecosystem (including TypeScript and React plugins), ability to coexist with formatters like Prettier, and granular configuration let projects tailor linting to their needs. Active maintenance, a clear semantic versioning policy, frequent releases, and broad community adoption keep ESLint trending as a reliable code-quality tool.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>8. <a href="https://github.com/anthropics/claude-plugins-official" target="_blank" rel="noopener noreferrer">anthropics/claude-plugins-official</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Official, Anthropic-managed directory of high quality Claude Code Plugins.</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">7,934</span>
                        | <span class="today">75 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository is Anthropicâ€™s official, curated marketplace of high-quality plugins for Claude Code, organizing both Anthropic-maintained internal plugins and third-party external plugins. Key features include a standard plugin layout (.claude-plugin with plugin.json metadata, optional .mcp.json for MCP server configuration, and optional commands/agents/skills directories), a reference example plugin, and submission and quality/security gating for external contributions. Technically, each plugin is packaged with metadata and optional server configuration so Claude Code can discover, install, and run capabilities (slash commands, agents, skills) via the clientâ€™s plugin system or the /plugin install command. The README also emphasizes trust and verification boundaries, directing users to individual plugin homepages and license files for details.</p>
<p>Developers, platform integrators, and Claude users benefit most from this project because it centralizes discovery, standardizes plugin structure, and simplifies secure installation and maintenance across an expanding assistant ecosystem. Third-party partners gain a vetted channel to distribute integrations while users gain confidence through Anthropicâ€™s curation and documentation. Itâ€™s trending because demand for extensible, composable AI assistants is rising, and an official, managed plugin marketplace accelerates adoption, interoperability, and rapid iteration of assistant capabilities.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>9. <a href="https://github.com/Effect-TS/effect-smol" target="_blank" rel="noopener noreferrer">Effect-TS/effect-smol</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Core libraries and experimental work for Effect v4</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">383</span>
                        | <span class="today">14 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Effect-TS/effect-smol is the core and experimental runtime library for Effect v4, implementing a lightweight, TypeScript-based functional effect system. It provides primitives and combinators for describing and composing synchronous and asynchronous effects, typed error handling, resource management, and concurrency (including lightweight fibers and a scheduler) while exposing a small runtime optimized for low overhead. The project is written in TypeScript and integrates with the broader Effect-TS ecosystem to support deterministic execution, testing, and interoperability with other libraries. Its API emphasizes pure, composable workflows and predictable execution semantics.</p>
<p>This project benefits TypeScript developers, library authors, and teams building back-end services, streaming systems, or large applications that need strong compile-time guarantees, deterministic concurrency, and robust resource safety. It is attractive to those who want the ergonomics of functional programmingâ€”composability, testability, and explicit error handlingâ€”applied to real-world asynchronous workloads in JavaScript/TypeScript. The repository is trending due to growing interest in bringing mature effect-system patterns (inspired by projects like ZIO) into the JS ecosystem, an active Effect-TS community, and the appeal of a minimal, performant runtime for simplifying async complexity. Experimental v4 work and ongoing improvements also draw contributors eager to shape next-generation effect tooling.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>10. <a href="https://github.com/google-research/timesfm" target="_blank" rel="noopener noreferrer">google-research/timesfm</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">TimesFM (Time Series Foundation Model) is a pretrained time-series foundation model developed by Google Research for time-series forecasting.</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">8,900</span>
                        | <span class="today">404 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>TimesFM is a pretrained, decoder-only time-series foundation model from Google Research designed for forecasting tasks; it provides off-the-shelf checkpoints (including TimesFM 2.5) and inference tooling for PyTorch and Flax. Technically it uses a decoder-only Transformer backbone trained on large corpora of time series to produce autoregressive point and quantile forecasts, with an optional 30M-parameter quantile head for continuous quantile prediction up to 1k horizon and support for covariates (XReg). The 2.5 release reduces model size to 200M parameters, extends context length to 16k, removes the explicit frequency indicator, and adds new inference flags and API improvements; models and checkpoints are distributed via a Hugging Face collection and integrated examples demonstrate normalization, multi-series inputs, and configurable forecast settings.</p>
<p>This project benefits data scientists, ML researchers, and forecasting engineers who need a scalable, pretrained model to accelerate model development, transfer learning, or production forecasting pipelines. Itâ€™s trending because it brings the foundation-model paradigm to time seriesâ€”offering long-context attention, continuous quantile outputs, compact high-performance checkpoints, and integrations (Hugging Face, BigQuery) that lower engineering frictionâ€”backed by an ICML paper and active tooling for practical adoption.</p>
                    </div>
                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>

<script>
(() => {
    const readKey = "gtd:read_days:gh:v1";
    const dayStr = "2026-02-21";

    let stored = [];
    try {
        stored = JSON.parse(localStorage.getItem(readKey) || "[]");
        if (!Array.isArray(stored)) {
            stored = [];
        }
    } catch (_err) {
        stored = [];
    }

    if (!stored.includes(dayStr)) {
        stored.push(dayStr);
        stored.sort();
        localStorage.setItem(readKey, JSON.stringify(stored));
    }

    const collapseParam = new URLSearchParams(window.location.search).get("collapse_seen");
    const collapseSeen = collapseParam === "0" ? false : true;

    function setCollapsed(repoEl, collapsed) {
        repoEl.classList.toggle("collapsed", collapsed);
        const button = repoEl.querySelector(".repo-toggle");
        if (button) {
            button.textContent = collapsed ? "Show details" : "Hide details";
            button.setAttribute("aria-expanded", String(!collapsed));
        }
    }

    const repos = Array.from(document.querySelectorAll("section.repo[data-seen-before]"));

    repos.forEach((repoEl) => {
        const toggle = repoEl.querySelector(".repo-toggle");
        if (!toggle) {
            return;
        }

        toggle.addEventListener("click", () => {
            setCollapsed(repoEl, !repoEl.classList.contains("collapsed"));
        });
    });

    const collapseBtn = document.getElementById("collapse-seen-btn");
    const expandBtn = document.getElementById("expand-all-btn");

    if (collapseBtn) {
        collapseBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => {
                if (repoEl.dataset.seenBefore === "1") {
                    setCollapsed(repoEl, true);
                }
            });
        });
    }

    if (expandBtn) {
        expandBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => setCollapsed(repoEl, false));
        });
    }

    if (collapseSeen) {
        repos.forEach((repoEl) => {
            if (repoEl.dataset.seenBefore === "1") {
                setCollapsed(repoEl, true);
            }
        });
    }
})();
</script>

</body>
</html>
