<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 22, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 22, 2026</h1>
        <nav>
            <a href="../">&larr; GitHub Calendar</a>
            <a href="../hn/2026-02-22/">Hacker News</a>
        </nav>
    </header>
    <main>
        <div class="repo-controls">
            <button id="collapse-seen-btn" type="button">Collapse Repos Not New Today</button>
            <button id="expand-all-btn" type="button">Expand All</button>
        </div>
        <p class="seen-help">Repos marked "Not new today" appeared on one or more previous daily pages.</p>
        <article>
            <div class="repos">

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>1. <a href="https://github.com/vxcontrol/pentagi" target="_blank" rel="noopener noreferrer">vxcontrol/pentagi</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">✨ Fully autonomous AI Agents system capable of performing complex penetration testing tasks</p>
                    <p class="meta">
                        <span class="language">Go</span> |
                        <span class="stars">5,876</span>
                        | <span class="today">2,118 stars today</span>
                    </p>
                    <p class="history">First seen: February 21, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>PentAGI is an autonomous penetration-testing platform that orchestrates LLM-driven agents to plan, research, and execute security assessments within sandboxed Docker environments. It integrates a suite of 20+ professional tools (nmap, metasploit, sqlmap), a long-term memory stored in PostgreSQL with pgvector, a Graphiti/Neo4j knowledge graph for semantic context, web-scraping and external search connectors, and automated container selection to run tasks safely. Technically it is a microservices stack (React/TypeScript UI, Go GraphQL API, task queue and asynchronous agents) with observability (Grafana/Langfuse/Prometheus-style components), extensive LLM provider support, and deployability via Docker Compose.</p>
<p>Security engineers, red teams, researchers, and organizations needing scalable, repeatable penetration testing will benefit from PentAGI because it automates routine discovery and exploitation workflows, preserves and indexes findings for reuse, and centralizes reporting and monitoring. It is trending due to advances in multi-agent LLM orchestration, growing demand for self-hosted and auditable AI-driven tools, and the practical combination of vector memory, knowledge graphs, and observability that make autonomous security workflows more reliable and useful in production environments.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>2. <a href="https://github.com/abhigyanpatwari/GitNexus" target="_blank" rel="noopener noreferrer">abhigyanpatwari/GitNexus</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">GitNexus: The Zero-Server Code Intelligence Engine - GitNexus is a client-side knowledge graph creator that runs entirely in your browser. Drop in a GitHub repo or ZIP file, and get an interactive knowledge graph wit a built in Graph RAG Agent. Perfect for code exploration</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">1,119</span>
                        | <span class="today">132 stars today</span>
                    </p>
                    <p class="history">First seen: February 22, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>GitNexus is a client-side knowledge-graph engine that indexes a codebase into a graph of dependencies, call chains, clusters, and execution flows, then exposes that structure to AI agents and an interactive browser UI. It provides a CLI with an MCP server for deep agent integrations and a zero-server Web UI (WASM) so you can drop a GitHub repo or ZIP and get a navigable graph plus a Graph RAG agent. Under the hood it uses Tree-sitter for parsing, KuzuDB for graph storage, hybrid BM25+semantic search with embeddings, and exposes tools such as query, context, impact, detect_changes, rename, and raw Cypher over MCP. The system also installs agent skills and editor hooks to automatically enrich agent workflows with codebase-aware context.</p>
<p>Developers, engineering teams, and anyone building or operating AI-powered code assistants benefit because GitNexus gives agents deterministic architectural context so they stop missing dependencies, breaking call chains, or shipping blind edits. Its local-first design (persistent KuzuDB for CLI, in-browser WASM for quick exploration) preserves privacy while scaling from single-repo exploration to multi-repo MCP deployments, with integrations for Claude Code, Cursor, and OpenCode. It’s gaining traction because the rise of LLM-based developer tools has exposed a need for precise, explainable, repo-level context—GitNexus converts code into an actionable knowledge graph that makes both small and large models more accurate and trustworthy.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>3. <a href="https://github.com/obra/superpowers" target="_blank" rel="noopener noreferrer">obra/superpowers</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">An agentic skills framework &amp; software development methodology that works.</p>
                    <p class="meta">
                        <span class="language">Shell</span> |
                        <span class="stars">57,173</span>
                        | <span class="today">772 stars today</span>
                    </p>
                    <p class="history">First seen: February 04, 2026 | Consecutive daily streak: 6 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Superpowers is a complete software development workflow for coding agents built around composable &quot;skills&quot; and starter instructions that make agents follow a consistent process. Key features include a modular skills library (TDD, systematic debugging, brainstorming, plan-writing, subagent-driven development, code review, and git worktree management), an enforced workflow that moves from spec elicitation to plan to task-level subagents, and a two-stage review system (spec compliance then code quality). Technically it ships as a plugin (Claude Code marketplace) with manual install paths for Codex and OpenCode, stores skills directly in the repository, and has agents fetch and execute skills, spawn subagents per task, and run automated verification and test-driven cycles. The repo also contains contribution guidance and update mechanics so skills can be extended and updated easily.</p>
<p>This project benefits developers, teams, and tool builders who want repeatable, evidence-driven AI-assisted engineering—especially those who need automated testing, clear task plans, and controlled parallel work via subagents. It’s gaining traction because it addresses practical pain points in agentic coding (avoiding ad-hoc behavior, enforcing RED‑GREEN‑REFACTOR, and integrating with git workflows) while offering an easy integration path for Claude Code and extensibility via an open-source MIT-licensed skill library.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>4. <a href="https://github.com/huggingface/skills" target="_blank" rel="noopener noreferrer">huggingface/skills</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">No description</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">1,751</span>
                        | <span class="today">247 stars today</span>
                    </p>
                    <p class="history">First seen: February 22, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This repository defines &quot;skills&quot;: self-contained folders that package instructions (SKILL.md with YAML frontmatter), scripts, templates, and resources so coding agents can perform common AI/ML tasks such as dataset creation, model training, evaluation, job management, and more. It includes ready-made skills (hf CLI, datasets, evaluation, jobs, model trainer, paper publisher, tool builder, Trackio) and provides installation/manifest support for multiple agent ecosystems (Claude/Claude Code, OpenAI Codex, Google Gemini CLI, Cursor) via AGENTS.md, gemini-extension.json, and Cursor plugin files. Technically, skills are interoperable artifacts that agents load to obtain step-by-step guidance and helper tooling; the repo also provides scripts to publish/regenerate manifests and CI checks to validate metadata and marketplace listings. The result is a standardized, reusable package format that lets agents orchestrate local or Hugging Face cloud workflows reliably.</p>
<p>This project is useful for ML engineers, MLOps teams, researchers, and developers who want to automate common model and dataset workflows through coding agents and the Hugging Face platform. It reduces manual orchestration, improves reproducibility, and makes it easy to share and extend operational patterns as installable agent plugins. Its momentum comes from the growing adoption of LLM-driven coding agents, the need for cross-platform interoperability, and tight integration with Hugging Face&#x27;s tooling and cloud compute, which together lower friction for running end-to-end ML tasks.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>5. <a href="https://github.com/PowerShell/PowerShell" target="_blank" rel="noopener noreferrer">PowerShell/PowerShell</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">PowerShell for every system!</p>
                    <p class="meta">
                        <span class="language">C#</span> |
                        <span class="stars">51,588</span>
                        | <span class="today">13 stars today</span>
                    </p>
                    <p class="history">First seen: February 22, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>PowerShell is a cross-platform automation and configuration framework that provides a command-line shell, scripting language, and a cmdlet processing framework optimized for structured data (JSON, CSV, XML), REST APIs, and object models. Technically, PowerShell 7+ is implemented on top of .NET (Core/.NET 5+), uses an object-based pipeline instead of plain text streams, and includes platform-specific build instructions and packaging for Windows, Linux, and macOS. The GitHub repository houses the full source, build/docs, contribution guidelines, governance and security policies, and channels for issues and discussions focused on PowerShell 7.x and later. It also documents telemetry, licensing (MIT), and container/image considerations for maintainers and downstream consumers.</p>
<p>System administrators, DevOps engineers, cloud and platform developers, and automation specialists benefit from PowerShell because it unifies scripting and tooling across heterogeneous environments and simplifies interacting with APIs and structured data. Its open-source, cross-platform redesign (PowerShell 7+) and deep .NET integration make it a natural fit for modern CI/CD, cloud automation, and multi-OS operational workflows. The project is trending due to active community contributions, growing adoption in cloud and automation toolchains, improved performance and compatibility with legacy scripts, and visible governance and documentation that encourage enterprise and community participation.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>6. <a href="https://github.com/anthropics/claude-code" target="_blank" rel="noopener noreferrer">anthropics/claude-code</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Claude Code is an agentic coding tool that lives in your terminal, understands your codebase, and helps you code faster by executing routine tasks, explaining complex code, and handling git workflows - all through natural language commands.</p>
                    <p class="meta">
                        <span class="language">Shell</span> |
                        <span class="stars">68,521</span>
                        | <span class="today">222 stars today</span>
                    </p>
                    <p class="history">First seen: February 22, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Claude Code is an agentic coding tool that runs in your terminal, IDE, or as a GitHub tag and interacts with your local codebase through natural-language commands. Key features include executing routine tasks, explaining complex code, managing git workflows, and an extensible plugins directory that adds custom commands and agents. Technically it inspects repository files, runs shell and git commands on your behalf, and uses a language-model-based agent to interpret instructions and orchestrate actions. Installation is supported via a single-script installer, Homebrew/WinGet, or other platform-specific methods, and the project collects usage and conversation feedback with documented privacy safeguards.</p>
<p>This tool benefits individual developers, reviewers, and engineering teams who want to speed up repetitive workflows, improve onboarding, and reduce context switching when navigating unfamiliar code. It is trending because AI-driven developer tooling and natural-language interfaces substantially raise productivity, the plugin architecture enables customization for diverse workflows, and easy installation plus community channels (Discord, GitHub) accelerate adoption. The combination of code-aware automation, git integration, and extensibility makes it an attractive option for modern development environments.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>7. <a href="https://github.com/stan-smith/FossFLOW" target="_blank" rel="noopener noreferrer">stan-smith/FossFLOW</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Make beautiful isometric infrastructure diagrams</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">17,855</span>
                        | <span class="today">74 stars today</span>
                    </p>
                    <p class="history">First seen: February 22, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>FossFLOW is an open-source Progressive Web App for creating beautiful isometric infrastructure diagrams in the browser, built with React and the Isoflow library (forked/published as fossflow on npm). It offers a component library, drag-and-drop canvas, a connector tool with click or drag modes, autosave, session and export/import storage, and optional server-backed persistence via a Docker image. Technically it is organized as a monorepo with packages/fossflow-lib (React component library built with Webpack) and packages/fossflow-app (PWA built with RSBuild), and includes npm scripts for development, building, testing, linting, and publishing. Documentation, contribution guidelines, and E2E test tooling are provided to support development and deployment.</p>
<p>Network architects, DevOps engineers, technical writers, educators, and UI designers benefit from FossFLOW because it enables fast production of consistent, attractive isometric diagrams and the library can be embedded into other projects or used standalone. It’s gaining traction due to its modern, accessible stack (React + PWA), offline and auto-save convenience, easy local or containerized deployment, and the ability to export/import or persist diagrams for collaboration and documentation. The MIT license, clear contribution workflow, and npm/Docker distribution further lower adoption barriers and encourage community-driven improvements.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>8. <a href="https://github.com/ggml-org/ggml" target="_blank" rel="noopener noreferrer">ggml-org/ggml</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Tensor library for machine learning</p>
                    <p class="meta">
                        <span class="language">C++</span> |
                        <span class="stars">14,087</span>
                        | <span class="today">47 stars today</span>
                    </p>
                    <p class="history">First seen: February 22, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>ggml is a compact, low-level C/C++ tensor library for machine learning designed for efficient inference and light-weight training. It provides core tensor primitives, automatic differentiation, integer quantization support, and built-in optimizers (ADAM and L‑BFGS) with zero runtime memory allocations and no third‑party dependencies. The code exposes optimized kernels and manual memory management to maximize throughput, and supports quantized GGUF model formats used by LLMs with example programs for GPT inference. Builds use CMake and offer cross‑platform targets (CPU vector intrinsics, CUDA, hipBLAS, SYCL, Android), relying on platform-specific backends to squeeze performance from diverse hardware.</p>
<p>Developers and researchers who need to run or prototype large models on resource‑constrained or heterogeneous hardware—such as edge/mobile engineers, inference practitioners, and contributors to open‑source LLM tooling—will benefit most from ggml’s small footprint and performance-oriented design. Its multi‑backend support, quantization capabilities, and zero‑allocation runtime make it well suited for deploying models outside data centers. The project is trending because of growing demand for efficient, portable inference of open‑source LLMs, active integration with projects like llama.cpp and whisper.cpp, and a community push toward running large models on consumer hardware.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>9. <a href="https://github.com/Stremio/stremio-web" target="_blank" rel="noopener noreferrer">Stremio/stremio-web</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Stremio - Freedom to Stream</p>
                    <p class="meta">
                        <span class="language">JavaScript</span> |
                        <span class="stars">9,501</span>
                        | <span class="today">301 stars today</span>
                    </p>
                    <p class="history">First seen: February 22, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Stremio Web is the web front-end for Stremio, a modern media center that helps users discover, watch and organize video content through a modular addon system. Key features include a centralized discovery interface, meta-details for content, and an addon-driven aggregation and playback model that lets the app surface streams from multiple sources. Technically it is a Node.js-based web application (requires Node.js 12+/npm 6+) with standard npm workflows (npm install, npm start for development, npm run build for production) and is distributed under the GPLv2 license. The repository provides the web UI assets and build pipeline used to run or package the client for production.</p>
<p>This project benefits end users looking for a single, extensible interface to browse and play content from diverse sources, as well as developers who want to create addons to add sources or enrich metadata. Its open-source, addon-centric design and web technology stack make it easy to extend, port, and contribute to, lowering the barrier for community-driven feature development. The simple Node/npm build process also makes it straightforward for contributors to run a development server or produce production builds. As streaming services proliferate, Stremio’s unified, extensible approach and active open-source ecosystem are key reasons for its traction.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>10. <a href="https://github.com/HandsOnLLM/Hands-On-Large-Language-Models" target="_blank" rel="noopener noreferrer">HandsOnLLM/Hands-On-Large-Language-Models</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Official code repo for the O&#x27;Reilly Book - &quot;Hands-On Large Language Models&quot;</p>
                    <p class="meta">
                        <span class="language">Jupyter Notebook</span> |
                        <span class="stars">22,643</span>
                        | <span class="today">355 stars today</span>
                    </p>
                    <p class="history">First seen: February 14, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Summary not available.</p>
                    </div>
                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>

<script>
(() => {
    const readKey = "gtd:read_days:gh:v1";
    const dayStr = "2026-02-22";

    let stored = [];
    try {
        stored = JSON.parse(localStorage.getItem(readKey) || "[]");
        if (!Array.isArray(stored)) {
            stored = [];
        }
    } catch (_err) {
        stored = [];
    }

    if (!stored.includes(dayStr)) {
        stored.push(dayStr);
        stored.sort();
        localStorage.setItem(readKey, JSON.stringify(stored));
    }

    const collapseParam = new URLSearchParams(window.location.search).get("collapse_seen");
    const collapseSeen = collapseParam === "0" ? false : true;

    function setCollapsed(repoEl, collapsed) {
        repoEl.classList.toggle("collapsed", collapsed);
        const button = repoEl.querySelector(".repo-toggle");
        if (button) {
            button.textContent = collapsed ? "Show details" : "Hide details";
            button.setAttribute("aria-expanded", String(!collapsed));
        }
    }

    const repos = Array.from(document.querySelectorAll("section.repo[data-seen-before]"));

    repos.forEach((repoEl) => {
        const toggle = repoEl.querySelector(".repo-toggle");
        if (!toggle) {
            return;
        }

        toggle.addEventListener("click", () => {
            setCollapsed(repoEl, !repoEl.classList.contains("collapsed"));
        });
    });

    const collapseBtn = document.getElementById("collapse-seen-btn");
    const expandBtn = document.getElementById("expand-all-btn");

    if (collapseBtn) {
        collapseBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => {
                if (repoEl.dataset.seenBefore === "1") {
                    setCollapsed(repoEl, true);
                }
            });
        });
    }

    if (expandBtn) {
        expandBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => setCollapsed(repoEl, false));
        });
    }

    if (collapseSeen) {
        repos.forEach((repoEl) => {
            if (repoEl.dataset.seenBefore === "1") {
                setCollapsed(repoEl, true);
            }
        });
    }
})();
</script>

</body>
</html>
