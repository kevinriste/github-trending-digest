<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Trending - February 20, 2026</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>GitHub Trending Digest - February 20, 2026</h1>
        <nav>
            <a href="../">&larr; GitHub Calendar</a>
            <a href="../hn/2026-02-20/">Hacker News</a>
        </nav>
    </header>
    <main>
        <div class="repo-controls">
            <button id="collapse-seen-btn" type="button">Collapse Repos Not New Today</button>
            <button id="expand-all-btn" type="button">Expand All</button>
        </div>
        <p class="seen-help">Repos marked "Not new today" appeared on one or more previous daily pages.</p>
        <article>
            <div class="repos">

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>1. <a href="https://github.com/obra/superpowers" target="_blank" rel="noopener noreferrer">obra/superpowers</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">An agentic skills framework &amp; software development methodology that works.</p>
                    <p class="meta">
                        <span class="language">Shell</span> |
                        <span class="stars">55,569</span>
                        | <span class="today">889 stars today</span>
                    </p>
                    <p class="history">First seen: February 04, 2026 | Consecutive daily streak: 4 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Superpowers is a complete software development workflow for coding agents built around composable &quot;skills&quot; and starter instructions that make agents follow a consistent process. Key features include a modular skills library (TDD, systematic debugging, brainstorming, plan-writing, subagent-driven development, code review, and git worktree management), an enforced workflow that moves from spec elicitation to plan to task-level subagents, and a two-stage review system (spec compliance then code quality). Technically it ships as a plugin (Claude Code marketplace) with manual install paths for Codex and OpenCode, stores skills directly in the repository, and has agents fetch and execute skills, spawn subagents per task, and run automated verification and test-driven cycles. The repo also contains contribution guidance and update mechanics so skills can be extended and updated easily.</p>
<p>This project benefits developers, teams, and tool builders who want repeatable, evidence-driven AI-assisted engineering‚Äîespecially those who need automated testing, clear task plans, and controlled parallel work via subagents. It‚Äôs gaining traction because it addresses practical pain points in agentic coding (avoiding ad-hoc behavior, enforcing RED‚ÄëGREEN‚ÄëREFACTOR, and integrating with git workflows) while offering an easy integration path for Claude Code and extensibility via an open-source MIT-licensed skill library.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>2. <a href="https://github.com/RichardAtCT/claude-code-telegram" target="_blank" rel="noopener noreferrer">RichardAtCT/claude-code-telegram</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">A powerful Telegram bot that provides remote access to Claude Code, enabling developers to interact with their projects from anywhere with full AI assistance and session persistence.</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">1,057</span>
                        | <span class="today">174 stars today</span>
                    </p>
                    <p class="history">First seen: February 20, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Claude Code Telegram is a Telegram bot that gives developers conversational, remote access to Claude Code for analyzing, editing, testing, and explaining codebases without needing a terminal. It supports an agentic natural-language mode and a classic terminal-like mode, automatic per-project session persistence, proactive notifications from webhooks and scheduled jobs, file and image uploads, and safe Git/gh workflows. The bot integrates with Claude via the Python SDK or CLI fallback, uses the Telegram Bot API for chat interactions, persists state and audits in SQLite, and implements directory sandboxing, authentication, rate limiting, and an event bus for decoupled automation.</p>
<p>This tool benefits individual developers, on-call engineers, and small teams who want AI-assisted code review, quick fixes, CI/CD integrations, or chat-driven DevOps without switching contexts. It streamlines common workflows (tests, branches, repo navigation, webhook handling) and enforces security and cost controls, making it practical for production use. Its popularity follows the broader trend toward conversational developer tooling and ChatOps‚Äîbringing powerful LLM capabilities directly into everyday messaging platforms.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>3. <a href="https://github.com/open-mercato/open-mercato" target="_blank" rel="noopener noreferrer">open-mercato/open-mercato</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">AI‚Äësupportive CRM / ERP foundation framework ‚Äî built to power R&amp;D, new processes, operations, and growth. It‚Äôs modular, extensible, and designed for teams that want strong defaults with room to customize everything. Better than Django, Retool and other alternatives - and Enterprise Grade!</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">790</span>
                        | <span class="today">56 stars today</span>
                    </p>
                    <p class="history">First seen: February 20, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Open Mercato is an AI‚Äësupportive platform for shipping enterprise‚Äëgrade CRMs, ERPs, and commerce backends that emphasizes modularity and extensibility: modules auto‚Äëdiscover frontends, APIs, CLI, i18n, and per‚Äëmodule MikroORM entities/migrations while allowing overlay overrides and dynamic custom entities/forms. Key features include multi‚Äëtenant and multi‚Äëhierarchical org support, feature‚Äëbased RBAC, event subscribers/workflows, hybrid JSONB indexing/caching, and tenant‚Äëscoped field‚Äëlevel encryption with deterministic hashes for lookups. It also embeds an AI Assistant using MCP for schema and API discovery/execution and Meilisearch for hybrid fulltext/vector search, and is implemented as a TypeScript monorepo using Next.js App Router, zod, Awilix DI, MikroORM, JWT sessions, and Docker compose for dev/prod. The project includes CLI utilities, growing test coverage, and a developer workflow (yarn 4, Node 24) aimed at production readiness and easy customization.</p>
<p>Product teams, SaaS builders, and enterprises that need a customizable, secure, multi‚Äëtenant backend for CRM/ERP/commerce use cases will benefit most because Open Mercato delivers an ‚Äú80% done‚Äù foundation that reduces time‚Äëto‚Äëmarket while preserving full control over bespoke business logic. Its combination of field‚Äëlevel encryption, RBAC, per‚Äëtenant keys, and per‚Äëmodule migrations addresses compliance and operational concerns, while the headless API and built‚Äëin AI tooling accelerate R&amp;D and automation. It‚Äôs trending because it pairs modern developer ergonomics and modular architecture with built‚Äëin AI integrations and search, making it attractive for teams looking to ship production‚Äëgrade, extensible systems quickly.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>4. <a href="https://github.com/harvard-edge/cs249r_book" target="_blank" rel="noopener noreferrer">harvard-edge/cs249r_book</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Introduction to Machine Learning Systems</p>
                    <p class="meta">
                        <span class="language">JavaScript</span> |
                        <span class="stars">20,306</span>
                        | <span class="today">663 stars today</span>
                    </p>
                    <p class="history">First seen: February 19, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>This project is an open &quot;learning stack&quot; and living textbook that teaches AI engineering by combining a textbook source with runnable tooling: TinyTorch (a minimal teaching framework), benchmarking suites, and hardware lab kits for edge devices. Key features include modular chapters that bridge ML concepts to systems topics (memory, latency, quantization, MLOps), reference implementations (autograd, optimizers, attention), hands‚Äëon modules from CNNs to transformers, and reproducible benchmarks (e.g., MLPerf-style experiments). Technically it ships code, labs, and deployment instructions so learners can build, measure, and deploy models on constrained hardware (Arduino, Raspberry Pi and similar), with a research-to-teaching loop that turns reference systems and benchmarks into curriculum. The repo organizes paths to read, build, explore, and deploy, and is maintained as a living resource with community contributions.</p>
<p>Students, instructors, researchers, and engineers who need practical, end‚Äëto‚Äëend expertise in building reliable, efficient AI systems benefit most‚Äîfrom classroom teaching to production and edge deployment. It‚Äôs trending because the community recognizes a gap between model-centered ML research and the systems engineering required to run models safely and efficiently in the real world, and this project offers open, hands‚Äëon tooling and benchmarks that address that gap. The combination of a compact teaching framework (TinyTorch), reproducible benchmarks, hardware kits, and an active community makes it useful for training, curriculum development, and applied research.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>5. <a href="https://github.com/HailToDodongo/pyrite64" target="_blank" rel="noopener noreferrer">HailToDodongo/pyrite64</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">N64 Game-Engine and Editor using libdragon &amp; tiny3d</p>
                    <p class="meta">
                        <span class="language">C++</span> |
                        <span class="stars">1,830</span>
                        | <span class="today">608 stars today</span>
                    </p>
                    <p class="history">First seen: February 19, 2026 | Consecutive daily streak: 2 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Pyrite64 is an open-source Nintendo 64 game engine and editor that targets homebrew development by leveraging libdragon for hardware abstraction and tiny3d for low-level GPU rendering. The project bundles an in-console runtime with an editor and asset pipeline so creators can design scenes, manage resources, and build ROMs or run in emulators. Key features include a real-time 3D renderer, input and file I/O integration, and build scripts/tooling to cross-compile and package content for N64 hardware. Technically it ties together the N64 toolchain, libdragon APIs, and tiny3d primitives to deliver an integrated development workflow for the console.</p>
<p>This project benefits retro developers, hobbyists, educators, and anyone interested in creating or studying N64-era games because it lowers the barrier to producing and iterating on content for the console. It is trending in the homebrew and preservation communities due to renewed interest in retro platforms, improving cross-compile toolchains, and the appeal of a single repository that combines editor, engine, and deployment tools for rapid prototyping on real hardware or emulators.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>6. <a href="https://github.com/openclaw/openclaw" target="_blank" rel="noopener noreferrer">openclaw/openclaw</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Your own personal AI assistant. Any OS. Any Platform. The lobster way. ü¶û</p>
                    <p class="meta">
                        <span class="language">TypeScript</span> |
                        <span class="stars">212,432</span>
                        | <span class="today">3,390 stars today</span>
                    </p>
                    <p class="history">First seen: February 02, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>OpenClaw is a local-first personal AI assistant platform that you run on your own devices to answer and act across the messaging surfaces you already use (WhatsApp, Telegram, Slack, Discord, Google Chat, Signal, iMessage/BlueBubbles, Teams, Matrix, Zalo, WebChat, etc.). Technically it centers on a Gateway control plane (WS API) that coordinates per-agent sessions, a CLI onboarding wizard and daemon, Pi-style agent runtimes, and companion nodes/apps for macOS, iOS and Android. It integrates model auth/failover (Anthropic/OpenAI and others), a media pipeline, browser control, Canvas/A2UI for visual workspaces, and first-class tools (cron, sessions, nodes, actions) with security defaults for DM handling. Installation and development target Node ‚â•22 with npm/pnpm/bun, plus optional Tailscale exposure and declarative Nix/Docker deployment paths.</p>
<p>This project is valuable for privacy-conscious individuals, power users, and teams who want a single always-on assistant that integrates messaging, voice, browser automation, and custom skills while keeping control of data and models. Use cases include personal productivity across channels, automated ops and alerts, multi-agent routing for complex workflows, and local voice/Canvas-driven interactions on desktop and mobile. It‚Äôs trending because it combines open-source extensibility with multi-channel reach and the rising demand for private, long-context AI assistants that can orchestrate tools and devices rather than just chat.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="0">
                <div class="repo-header-row">
                    <h3>7. <a href="https://github.com/freemocap/freemocap" target="_blank" rel="noopener noreferrer">freemocap/freemocap</a> </h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Free Motion Capture for Everyone üíÄ‚ú®</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">5,299</span>
                        | <span class="today">141 stars today</span>
                    </p>
                    <p class="history">First seen: February 20, 2026 | Consecutive daily streak: 1 day</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Freemocap is an open-source motion-capture system and platform that enables users to capture, visualize, and export motion data through a Python-based graphical interface. Key features highlighted in the repository include a one-command pip install, a standalone GUI launched via the freemocap entry point, detailed quickstart and from-source installation instructions (conda environments and pip install -e .), and comprehensive documentation and tutorials. Technically the project is implemented as a Python package (supports Python 3.10‚Äì3.12), packaged with pyproject.toml, uses an entry-point module to start the GUI, and is positioned for decentralized scientific research, education, and training under the AGPL license.</p>
<p>Researchers, educators, students, and labs looking for an accessible, reproducible motion-capture workflow will benefit most because the project lowers barriers to entry with easy installation, clear docs, and source-code access for customization. It is gaining traction because it combines the familiar Python ecosystem, active community touchpoints (documentation site, Discord, contribution guidelines), and an open-source license that encourages sharing and reuse in academic and teaching contexts. The maintainers‚Äô emphasis on quickstarts and extensibility makes it appealing for rapid adoption in experiments, courses, and prototyping.</p>
                    </div>
                </div>
            </section>

            <section class="repo" data-seen-before="1">
                <div class="repo-header-row">
                    <h3>8. <a href="https://github.com/p-e-w/heretic" target="_blank" rel="noopener noreferrer">p-e-w/heretic</a> <span class="seen-badge">Not new today</span></h3>
                    <button type="button" class="repo-toggle" aria-expanded="true">Hide details</button>
                </div>
                <div class="repo-body">
                    <p class="description">Fully automatic censorship removal for language models</p>
                    <p class="meta">
                        <span class="language">Python</span> |
                        <span class="stars">8,576</span>
                        | <span class="today">652 stars today</span>
                    </p>
                    <p class="history">First seen: February 08, 2026 | Consecutive daily streak: 4 days</p>
                    <div class="ai-summary">
                        <h4>Analysis</h4>
                        <p>Heretic is a tool for automatically removing censorship (safety alignment) from transformer-based language models by applying directional ablation (aka &quot;abliteration&quot;) combined with a TPE-based parameter optimizer implemented with Optuna. The system automatically searches for abliteration parameters that co-minimize the number of refusals on &quot;harmful&quot; prompts and the KL divergence from the original model on &quot;harmless&quot; prompts, producing decensored models that retain as much capability as possible without costly post-training. It supports most dense and many multimodal and MoE architectures, includes bitsandbytes quantization to reduce VRAM requirements, and provides built-in benchmarking, evaluation, saving/uploading to Hugging Face, and an interactive test/chat option. Optional research features expose interpretability tooling such as PaCMAP projections of residuals, residual-geometry metrics, layer-wise plots, and animations to study how harmful/harmless signals evolve through the network.</p>
<p>Heretic benefits researchers and engineers who want to study or deploy models with fewer safety refusals while preserving original capabilities, as well as hobbyists and operators constrained by GPU memory who can leverage quantization and automatic configuration. It is trending because it automates a previously expert-driven process, reporting abliterations that match or outperform manual efforts on refusal suppression with lower KL damage, and because community-shared decensored models and positive user feedback have driven visibility. Its combination of practical usability, research-focused diagnostics, and competitive empirical results makes it attractive to both the interpretability community and practitioners seeking controllable model behavior.</p>
                    </div>
                </div>
            </section>

            </div>
        </article>
    </main>
    <footer>
        <p>Generated automatically. Data from <a href="https://github.com/trending">GitHub Trending</a>.</p>
    </footer>

<script>
(() => {
    const readKey = "gtd:read_days:gh:v1";
    const dayStr = "2026-02-20";

    let stored = [];
    try {
        stored = JSON.parse(localStorage.getItem(readKey) || "[]");
        if (!Array.isArray(stored)) {
            stored = [];
        }
    } catch (_err) {
        stored = [];
    }

    if (!stored.includes(dayStr)) {
        stored.push(dayStr);
        stored.sort();
        localStorage.setItem(readKey, JSON.stringify(stored));
    }

    const collapseParam = new URLSearchParams(window.location.search).get("collapse_seen");
    const collapseSeen = collapseParam === "0" ? false : true;

    function setCollapsed(repoEl, collapsed) {
        repoEl.classList.toggle("collapsed", collapsed);
        const button = repoEl.querySelector(".repo-toggle");
        if (button) {
            button.textContent = collapsed ? "Show details" : "Hide details";
            button.setAttribute("aria-expanded", String(!collapsed));
        }
    }

    const repos = Array.from(document.querySelectorAll("section.repo[data-seen-before]"));

    repos.forEach((repoEl) => {
        const toggle = repoEl.querySelector(".repo-toggle");
        if (!toggle) {
            return;
        }

        toggle.addEventListener("click", () => {
            setCollapsed(repoEl, !repoEl.classList.contains("collapsed"));
        });
    });

    const collapseBtn = document.getElementById("collapse-seen-btn");
    const expandBtn = document.getElementById("expand-all-btn");

    if (collapseBtn) {
        collapseBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => {
                if (repoEl.dataset.seenBefore === "1") {
                    setCollapsed(repoEl, true);
                }
            });
        });
    }

    if (expandBtn) {
        expandBtn.addEventListener("click", () => {
            repos.forEach((repoEl) => setCollapsed(repoEl, false));
        });
    }

    if (collapseSeen) {
        repos.forEach((repoEl) => {
            if (repoEl.dataset.seenBefore === "1") {
                setCollapsed(repoEl, true);
            }
        });
    }
})();
</script>

</body>
</html>
